<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0046)https://articles.zsxq.com/id_dw8bqknsxwqg.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <link rel="icon" href="https://articles.zsxq.com/favicon.ico">
    <title>CPPRaft系列-raft算法主要流程函数实现-03</title>
    <link rel="stylesheet" href="./CPPRaft系列-raft算法主要流程函数实现-03_files/quill.snow.css">
    <link rel="stylesheet" href="./CPPRaft系列-raft算法主要流程函数实现-03_files/github.css">
    <style>
        body {
            margin: 0px;
            font-size: 14px;
            background: #f0f3f8;
            font-family: "PingFangSC-Regular","Helvetica Neue",Helvetica,"Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;
        }
        .top-bar {
            height: 60px;
            background: #EBEBEB;
        }
        .post {
            margin: 0 auto;
            width: 800px;
            padding: 40px;
            box-sizing: border-box;
            position: relative;
            background-color: white;
        }
        .post .title {
            margin: 0px;
            font-family: PingFangSC-Medium;
            font-size: 20px;
            color: #1A1A1A;
            line-height: 30px;
        }
        .group-info {
            margin-top: 8px;
            font-size: 14px;
            color: #567895;
        }
        .group-info a {
            color: #567895;
            text-decoration: none;
        }
        .author-info {
            margin-top: 30px;
            margin-bottom: 24px;
            height: 24px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .author-info .author {
            display: flex;
            align-items: center;
        }
        .author-info img {
            height: 24px;
            width: 24px;
            border-radius: 12px;
        }
        .author-info .date {
            color: #B3B3B3;
        }
        .author-info .nick-name {
            color: #4D4D4D;
            margin-left: 12px;
        }
        .content {
            letter-spacing: 0;
            color: #2F3034;
            font-size: 16px;
            word-wrap: break-word;
            line-height: 28px;
            white-space: pre-wrap;
        }
        .content div, .content p {
            line-height: 28px;
        }
        .content figure {
            margin-inline-start: 0px;
            margin-inline-end: 0px;
        }
        .content img {
            max-width: 100%;
            object-fit: cover;
            display: inline-block;
        }
        .content a {
            text-decoration: none;
            color: #567895;
        }
        .content a:hover {
            text-decoration: underline;
        }
        .content p {
            margin: 0px;
            white-space: pre-wrap;
            tab-size: 4;
        }
        .content table {
            display: block;
            overflow: auto;
            border: none;
            border-collapse: collapse;
            empty-cells: show;
            max-width: 100%
        }
        .content table td {
            min-width: 5px
        }
        .content table td,.content table th {
            border: 1px solid #ddd
        }
        .content table td:empty,.content table th:empty {
            height: 20px
        }
        .content table th {
            background: #ececec
        }
        .content blockquote {
            color: #9a9a9a;
            margin: 15px 0 !important;
            border-left: 3px solid #ccc !important;
            padding-left: 10px !important;
        }
        .content code {
            white-space: normal;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .content .article-hr {
            border-style: solid;
            border-width: 1px 0 0;
            border-color: rgba(0, 0, 0, 0.1);
            transform: scale(1, 0.5);
            margin: 15px 0;
        }
        .content ol {
            padding-left: 0;
        }
        .ql-snow .ql-editor .ql-code-block-container {
            background-color: rgba(0, 0, 0, 0.03);
            border: 1px solid #f0f0f0;
            border-radius: 2px;
            color: #333;
            white-space: pre-wrap;
        }
        .content .ql-syntax {
            background-color: #23241f;
            color: #f8f8f2;
            overflow: visible;
            white-space: pre-wrap;
            margin-bottom: 5px;
            margin-top: 5px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        .content pre {
            white-space: pre-wrap;
        }
        .content ol, .content ul {
            margin: 0;
        }
        .ql-align-center {
            text-align: center;
        }
        .ql-align-right {
            text-align: right;
        }
        ul {
            list-style-type: disc;
        }
        footer {
            margin-top: 48px;
            margin-bottom: 48px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        footer img {
            width: 18px;
            height: 18px;
            margin-left: 15px;
        }
        footer .text {
            font-size: 15px;
            color: #16B998;
            margin: 0 15px 0 6px;
        }
        footer .horizon-line {
            border-bottom: 1px solid rgba(0,0,0,0.08);
            width: 50px;
        }
        .qrcode-container {
            position: absolute;
            left: 820px;
            top: 0px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px 20px 15px 20px;
            border: 2px solid rgba(0,0,0,0.05);
        }
        .qrcode-container img {
            width: 140px;
            height: 140px;
            margin-bottom: 15px;
        }
        .qrcode-container .text-desc {
            font-size: 12px;
            color:#B3B3B3;
        }
        #qrcode-url {
            display: none;
        }
        .message-container-overlay {
            position: fixed;
            left: 50%;
            top: 50px;
            width: 400px;
            margin-left: -200px;
            margin-top: 10px;
            z-index: 99;
        }
        .message-item {
            margin-top: 5px;
            height: 40px;
            background: rgba(252, 192, 96, .9);
            box-shadow: 0 2px 8px 0 rgba(227, 169, 33, .2);
            z-index: 50;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
        }
        .js-disable-copy {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        li.ql-indent-1:not([data-list]) {
            counter-increment: list-1;
            margin-left: 1.2em;
        }
        li.ql-indent-2:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-2;
            margin-left: 2.7em;
        }
        li.ql-indent-3:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-3;
            margin-left: 4.2em;
        }
        li.ql-indent-4:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-4;
            margin-left: 5.7em;
        }
        li.ql-indent-5:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-5;
            margin-left: 7.2em;
        }
        li.ql-indent-6:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-6;
            margin-left: 8.7em;
        }
        li.ql-indent-7:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-7;
            margin-left: 10.2em;
        }
        li.ql-indent-8:not([data-list]) {
            list-style-type: circle;
            counter-increment: list-8;
            margin-left: 11.7em;
        }
        ol {
            counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;
        }
        ol li:not([data-list]) {
            list-style-type: none !important;
            counter-increment: list-0;
        }
        ol li:not([data-list])::before {
            display: inline-block;
            content: counter(list-0, decimal) ".";
            position: relative;
            left: -10px;
        }
        ol li.ql-indent-1:not([data-list])::before {
            content: counter(list-1, decimal) ".";
        }
        ol li.ql-indent-2:not([data-list])::before {
            content: counter(list-2, decimal) ".";
        }
        ol li.ql-indent-3:not([data-list])::before {
            content: counter(list-3, decimal) ".";
        }
        ol li.ql-indent-4:not([data-list])::before {
            content: counter(list-4, decimal) ".";
        }
        ol li.ql-indent-5:not([data-list])::before {
            content: counter(list-5, decimal) ".";
        }
        ol li.ql-indent-6:not([data-list])::before {
            content: counter(list-6, decimal) ".";
        }
        ol li.ql-indent-7:not([data-list])::before {
            content: counter(list-7, decimal) ".";
        }
        ol li.ql-indent-8:not([data-list])::before {
            content: counter(list-8, decimal) ".";
        }
        ol li.ql-indent-9:not([data-list])::before {
            content: counter(list-9, decimal) ".";
        }
        h1, h2, h3, h4, h5, h6 {
            margin: 0;
        }
    </style>
</head>

<body>
    <div class="post js_watermark quill-editor" style="background-repeat: repeat; background-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAADeCAYAAADFAGScAAAAAXNSR0IArs4c6QAAIABJREFUeF7tnYuS5DpuBdtev/7/b9deP+LMTq5xcUmV1FXVJUrZERPTD0lFJnkoggTAf/rySwISkIAEJCABCUhAAhKQwA8R+Kcf+hw/RgISkIAEJCABCUhAAhKQwJcGyONOEEb/+/gyr5CABE5IQP2esFEskgR2ElC/O0F5mQROSGBTvxog2y32L19fX//69fX116+vr/85YeNaJAlIYE5A/do7JLAugbx7//L19fWfvn/XbURLfksCsS3y/t3UrwbIdt/4t98Q/+vr6yv//JKABNYhoH7XaStLKoFKIHMTDJC8e/8mHglIYBkC0W/ev//8e+481K8GyNcvN7SRixUA87d8n1UYXbGW6f8W9CYE1O9NGtpqXpLATL+ZuMQA4Z0bI8T37yW7gJVamMBT+r27AZJB7t9/r670HQ4GwFhuGQjz9/9euKNYdAlcjYD6vVqLWp87EYh7Rt6tecf2FdL8Lf/i+pz/83ffv3fqHdb17ASO6Dfz5z+FMdzdAAnAGCAZ2PoOBwNgwGUrKfB0wzq7JCzfnQio3zu1tnW9GoH4iOfdGuOi73BE21lgyLs5Rkr+1w3raj3A+qxKILYDBki0WfXL3/L/pn6vboBQv9nWbQa2DHK4WFULLX/LV8BmoMy/BKPny63gVWVjuVcioH5Xai3LKoE/EtjSL0Gqef/ynuX9y9/yno3RUYNZff/ayyTwMwReod8YINFvdJ5F/j/o9+oGSFZXMojNdi7Y2WCrl+uI/2DbN/ByLf5uMUQ0Qn5GBH7KfQmo3/u2vTVfmwBB5DEqRjsX9e95/9YdjrxvM2nJ7/KPldbck+cZj7l237D05yewV7+ZB7NTic7Rb37GhTIL+n/S75UNkFQ4g9hswMLIiNERYKQLC9B8zwDIVnC6TJ7FLsj5u5AllMC6BNTvum1nye9NgB0M3qGjAPI6Scn3ZMvZev/iKn1vutZeAu8lgPHBwsAj/ea63MMCPnNmjBN2Of+k3ysYIGzvVEg1fd8sgBwjI6sp1RiJkcH5AazA5H+C0s1J/t7O79PvRUD93qu9re21CES/eX9mtZOMkWia3YtRAHmNsewrpiw+1Pdvvd4zua7Vh6zNZwjUWI2qX3Yr0G8PIOc+Fg2qfjMG4DKJftkFiYb/8KwrGCBx00jF6mGB+TkgUvEEmY8CyGuMR5o/11V/1MCrblbdLeszXcZPlcC1CKjfa7WntbkPAVZK8e/GMOD9m/dn9N0DyHuMB+/WPIe4j/7+7W5Z96FsTSXwHgLorsZA53t0+F39YmTU+XNfZPhVo9UNkAqQSPzeVDWAHCDcx85GBsx85e/ucLyns/tUCXQC6tc+IYF1CeAVwA7IKNajBpDz/uW+/v5lodAdjnX7hCVfhwA6TIlHWeZYKGCBoeqX8IYeojBMtztDcnYDhBWW2SFEAMyA1SFRZwLI6zkenB8QoBU8Z4KY7m8dEVnS8xJQv+dtG0smgUcEiI3EPaNfjxtz3r/4gPfkLFxT3bDyOxJM8HvGCs/7eNQq/l0C+wi8Ur/VsEC/0T1uVt/S79kNENwzsisxOoQIX9MMWrl2dlhg/pYv0oDl+9S9D5b4vtXr9jW1V0lAAp2A+rVPSGBNAtW9avZeJf6DuMmR8cBzejbK/v5ltTW0PG9rzT5jqc9DYOReVUtX4z/Q72j34q36PasBQqUp3+wQQNLoYoDMUu6O3LDO01UsiQSuRUD9Xqs9rc29COCvzft35p7BAYF5P+f7WcrdkRvWvYhaWwn8HIFX6nfmhvWS2nzaAKmg6uoJ1lt2ItjC7WdvcA1WG0YGOyV1FSXX6l71ki7jQyTwDwLq184ggXUJoN/UAFeKfM/v8w4l+1Q/e6MHldb3L4HkkMFVWveqdfuKJT8fAbSZknHmRtVvfkeMxpZ+yVwVnWYR4cf0+0kDpA9YpMvt8RejGI5Arml0aYh6oFF32dK96nwCskTrElC/67adJZdAX7AjRWZ/b45iOHj/ck99/2Jk1OfoXmV/k8DrCNRdiZp5buQqiX6rexXuV5lbY6Rwlge7nTURxNv0+ykDhN2LurW7tU07iuEgV3iala1fIHpY4Os6u0+SQCegfu0TEliXwGhHYnQeT2o48gFnQpJ76u4J2SSNoVy3b1jy8xPoKanRY/7vCZtm+uWsPPRLIqf8/GP6/QkDJBXtWzq4RFWLrbpa9S4wiuGogx/B5HlGPs9UuucXkSVcg4D6XaOdLKUERgsFpMusOxIjA6S6Wo3ev/l7deMYvX9ZRDyUitNmk4AEhgQwLMg2xUXoF53VHY1uPIxiOLies/I4QPTHD/t8twHCieIB2HclMrEJSGI1CGgbpcA9EsOBH5t9WgISeI6A+n2On3dL4JME6oniPQNkPcGcScosRuNIDIfv30+2uJ99FQJ1lzGLB4/0S/jBKFvsafX7KgMkz+kpbauPKasn/YAhrsn9HErEFlC/FoNF96qrSMx6nIWA+j1LS1gOCRwn8Ei/LPTtef+SSXLkA57P+TH3jOMYvEMCSxLo+q27FuxO9F1FrsHtEReqpfT7rAGCy1MGONys2NGIccEWD+lye37vGkiOAZNrGeiqUaN71ZLastAnJqB+T9w4Fk0CDwiwgMeuQ3Yw8CDg/Zt36My7oLpcMNHJtfnqvuS6V9kdJfA6ArhBEXtFHHP0W12kZvqtbldolXiPrl+uJWlEX4h4Xa0OPukZA4TJC4Ne/7kWhd2LngqM01CrYULWqx7HAcTslPTdloPV9nIJ3J6A+r19FxDAwgQwCHCb6j9TtVmAKpOVfnbHKGtOnuX7d+HOYtFPRaAaBKTPZTGgu0G+Sr+ZV+dZpNk9BZA9BgiwcJPCemKFpfqczVLdzlLpjrJbMTHq536cApiFkMBiBNTvYg1mcSVQCOzVLxMVVj8rxFEqXQyQfnivhwba/STwOgKZ++ZfvjJ3zj80zc8Y+CR2mHkK9VS6JIjh+mrY9MX+19XohU96ZIDUINR8bECmYqNAl/x9K04jBwH2E80zMMYIIRsWwTJ5fm+EF1bbR0ngFgTU7y2a2UpelABB5Cz65X09yvVfJzCjOI38Lu/ZfqI5LlysulZDZZQM5qKYrZYEXk6ABQGy0KHRWYbWutMxymTV9VtduDBM2EXpOn955V71wC0DpKf6qgbGyLqaDXKUdZRKN3/rfqyzAfZVdfY5ErgDAfV7h1a2jlclUF0yWDUlc1WPz2BxMAbLLJPVbGejvn+ZuMwWGK/K2npJ4NUEvqPfaDHa6/rDOGEDgBAEfp/Pyt9YuD9NjMcjqBggGA91hyK/o1I8ZxafgSHRc4XXz8/zsgtSA+Uelc+/S0ACjwmo38eMvEICZyVQd/7ZeRi9f2fxGbx/yXY1ipE8korzrJwslwTOSGCmX2IuKPNWfNXW4sKeBYYzcnlYJgwQDIvcsBV7MYvPmMV49AKMYj4eFtILJCCBTQLq1w4igXUJ8F6N4bDluz3bxRjFeHQas5iPdalZcgmcg8Ae/W7FZ2wtLFDDS+oXAwSAqeyWC9Qoa1Xumf1+NAjmd2axOodwLMU1CKjfa7SjtbgnAdygSGU/coFiAtKzVs1+PyLJ+9737z37mbV+PYEaizE6g6MbEOq3tAEDErm/+Xl02NBs9aW7ZVVLb+aP+vpu4BMlcF0CrJDMkkCo3+u2vTVbnwD6HQWR48edWub7npWK2nNeQI//6KunvH9xnzaeY/3+Yw0+R6DOZ/P96HgIslfN9FsDzB/pN7qNpnMPKXo/V/s3fzIGBxH2gOpuWPiYjwwKDBBOMudQJIJpXG15cyP6+MsSIItVKkjs1EhP6veyXcCKLUyALFZ1Z6Prlx2MvC+Z7HQ3rLxTZwGq7H76/l24o1j00xFgLsxxE8x9R/ol0xUpd2f6HRkULCBwknldODjVmR3vaCEC3TJQYpmN0vWNzvfIvVh8CS7PF1k0NDre0Vo+824EGJy2/MJrtqvoTv3erZdY37MS6CeNj8pZs+Xk7z2TVd0hqanpef/mHmIrZ5Oks/KxXBI4K4G6kzjKOke5u377QsFe/ebdfbtF++q/ll0PBsBAzRcDWgY4rDdWY7DUMjnCEDlrZ7JcEjgzAYyI0cpJtDfLHZ46YaSo3zO3sGW7MoGZobEnuJR7eY/i6syEJKugTGpYJcUdK+/kTI58/165d1m3dxP4rn6rkYJ+OQuPXc/8X/XLZ+Ve0ubeVr+4VrHVw8CWBs/AlgGOazjNkYExf3On493S8PlXJ1D1NTrkM7uLGaiiURYG+JnVT/V79V5i/c5KgMWDWXwHO5Ij/eJ+1fVLHAhuVUxqwmDLneusjCyXBM5KoOp3FN8R7aHPXBv91RPN+TuLgVzTD9dm/px7b7fTMWv8DID/8fu8D6LzAyeDZj0TBBesywfFnFUllmt5AqNVDoyPasj3BBDRXv4x8OF6wQAXA4W4q7pjqX6X7zJW4EQERvpl8oJ+ewA5BgZ+5BwomGrxLs27tvt9R++4M1cXjrrwcCI0FkUCpyfwav3WkAX0y6K8+t3ZHdhC6sEurLhs+Z7v/Agvk8DtCWBoMKkACJOLDFzVlaoaJBnc2K7lvugz18ftCuOj3qN+b9/lBPBCArND/Hh/RtfVlWpLv2iejHZdv/ydHRW9DF7YkD7qlgRmSRwIGmd3Ek12/QYap4uzqJD/Mz9Wv090qUD0SwISeB8BBqxMUDJRGaW4zqfnuuxmkO1qq0Q99fX7Su+TJXBvAkxeol9iLkZEZkbK6No9sSH3pm7tJfAaAtXFipgL9fsatk8/RQPkaYQ+QAK/jAdWU7qbRFws2MGIK8ZWQDk7FwSUz9CSenPrWTaLBCSwj8BMv3W1k12OuF6wGlqfXncuZosMXE+g+exZ+0rtVRKQAIt3eAoQn8HvOSMruxq55ln9suuZd7D6fbL/aYA8CdDbb0+A3YgMcPnXV0rzMxOWRzscewyL6nf+aKJz+8YRgAQeEEBz6Df6qruQ6BdjZOtw3T2GRc37X9Pq2lASkMBxAlW/GB3ol4UFYq96iuu+gFCzYY0WGXK9+j3eRtM7NEBeCNNH3ZIAOfgxBjIJyb9+mGfgPNrh2IoVYScl12wdSnjLRrDSEvgGAYyKGjyOEdHjH/fscMzcsKobSIrpeR3faCxvkUAj0PXb46tqLMde/Y4O/FS/b+p6GiBvAutjL0eArdcMUHWFpR/8x2A1SuCwZ4djFkA+Cka/HGQrJIE3EaiuExgAI4Nh6/DARzscWwHk6vdNDetjb0Eg+ok22aEkRXU3GGb63eM69Ui/AT3bGblFI7y6khogrybq865GgElK/h/l4O8GAz6nI/cKdjhqitzOywDzq/Ug6/NJArhMkK2m5uDvE46Uk5S5MVJG2qwpNkf1MsD8k63tZ1+NQNcv6avzLla/i7e2BsjiDWjx307g0a4Fg2AmLvmebV+MjL5isidFLpOlt1fOD5DAxQns3bXo+iVldtXv1gppxah+L96prN6PENiza1Gz1NX3r/r9kSZ67kM0QJ7j593rE2DFMwPW6Itdi63g01HsBjEb3RWLHQ4OElyfoDWQwOcIPNLv7AyAbjDUAFV8y3MNB45xPSuyW+PB52j4yRJYhwAGRs1c1UuPfrcOwe4a36NfM1idoJ9ogJygESzCRwgQLE4A6pZvZ4wJrssEJF/18M48i0OMqMyWoZFsWFtuWB8B4odKYCEC6Dc62pqcMBnhupl+c111m5wZGrNEEQuhs6gS+CgBdhLJMLdXv8R91PcvRsxMv93QUL8fbfo/frgGyIkaw6K8nUAd+PAh3XOWRiY7xHbUQmZwy+A5ym7lTsfbm9MPuBmBrt9Uf89KZvQZDdevuvCA+1VNa+1Ox806l9V9OwF2Koin3KPf6uL8Hf3uGR/eXnE/YExAA8SecQcCrIJyGjluFVsB45ULGThibBDjkXvzvExaWFXBIOHz8v8oG9YdmFtHCbyKQPXzrmd0bAWMd/3mGVlBrcGrHEzG83GL5GcmSDWd56vq5HMkcBcCNY0tsRmp+1795j2bd2nVb96/7Hqo30V7kgbIog1nsXcRwDDI/2S1wWjgZNQMZN8xEvLMuFIxaWGXhEC4DJbdf3xXob1IAhL4RYCJS74nRgujgUM/OZH4qJHQU/CyS4J+PWvHTiiB5wh0/UZbGA2v0i/vWFwy8/y4W2LoHB0Xnquxdx8ioAFyCJcXL0Cg59uPkcBgVHcqiPlIfAf+4Ueq1w0Q7kVTDnxHaHqtBP5OoOoXvdZzOziHp55uTGrdIwy7AaJ+j9DzWgmMCURX+RrpsweU4ynwjH5HMR75fN+/C/RQDZAFGskiPiRAIBp+3t1NowaId7crfL2P7oLsSaf7sOBeIAEJ/FoVRYf1rJ2gIT4jEw38wbkmf986OHCGlufU1VibQQIS+B4BXJSjxapfdI3Oun75e93V3FMC9buH0gLXaIAs0EgWcUggfbcGtc1cJljpZKVkZHDULFdbuPE7ZZVnTwC7zScBCfyZQNUvLpL4eNerMTDIlNMNDlZRH+1i1kkLQbAGqNozJfA9AhgPxGewS9l3Hqp+cbuqBof6/R7/S9ylAXKJZrxVJRjQCCjPxKPGdbAqWtPkVjer7taR6/dmrMrnEMy6lbb3Vg1iZSVwgMBIv30FlPScBIxz+jhpOLMrUt029masUr8HGspLJdAIdKODd2zdSWRhof5tpN+aehf9bi0I8FxiPHz/XqB7aoBcoBFvUAVWLzPx4NCi6laFgcEAGSRkpMr3/ZyO6obFZIedEnc1btChrOKPEhjpt7plRI/4jOPGUQ/q3HLDQr91Z8TJyY82rx92cQI1Cx3v35F+c13dXcwiwZYbFgsKLCKSUEL9XrxDUT0NkJs09OLVxMCoafjyOwa4ms4vv2Olk7z+1bio2a8yyalnAOS+TIaq8bI4OosvgY8SqC4W6Bc9Vv2SuQb9MsFhR7Nmu6puHcR9oWWuI2vWRyvvh0tgcQLoN3piVwODJD8T/4ELJO/XPfpF60GUHZG6iKB+F+84e4qvAbKHkteciQArKjXgPINefiaQHDcrtnRHbldkx8pAV08m1wg5U2tblqsRqPqNbjFKqoHRs+XwM25X6JlJEYsRmcRkHNAIuVqvsT5nIdADzkfpsWf6xe2qGjUZA9AvBon6PUtrv7kcGiBvBuzjX0aASUcGNw4ErLEfPZ1uDyzvf2eikgLia55VHLLt8PuXVcAHSeDGBNj1iI7rTkj0lq/qJ94DU+uEhQnPSL813bb6vXFns+ovJ9D1mw+ouxxH9ItLJslceP+q35c327kfqAFy7vaxdP9PoO9idLcqJiSsgubvMSjYFekGSYyX/C7Xa3TY0yTwXgJ9F6NnsyJOK5OQ+n01UGqmKw4eI/sd7zLz/7+3HX36PQn0XY2q3xDBlZl4DpK1jPRbd0HV7z37069aa4DcuPEXrHoNJu8GCKuk+Z+t3hgYuGGNDhzESFkQhUWWwHIEajB5N0CY4KRS7JBw6GCMirrCSsXV73JdwAIvSqAHk6vfRRvyTMXWADlTa1iWRwQwOmJU4Iv6142byHYVg4TdDoPbHlH27xJ4D4EaPE7GHBJF9E/ETSPGR1ZVe+rd95TQp0pAAjMCVb/5Pho9ot+aelfKEnAHxD6wHAFcqdjizaA2mryQWzx/yyDJ9bpoLNfkFvgiBNilJFMOh5dt6TfXsuAwOqjwImishgROT6Dql1iu0YJeD1THxbmezXX6ylrA9xNwB+T9jP2E1xKoWW4yOakGBUYHgepk1SBo/bUl8WkSkMBRArhRosmRfuvkxoWDo4S9XgLvIcCuJG7O9f2LixY7I+i7Jp14T6l86rIENECWbbrbFpxgdGI7+snK9YTk20Ky4hI4KYFZMGt0jHZ1kzxp41ms2xOo+o0Bwvu3Lhp4kODtu8k+ABog+zh51bkIJLaDlRYy4zhpOVcbWRoJjAiwiop+NTrsJxJYhwBuWDFEMDqM7Vin/U5VUg2QUzWHhdlJgMMCE4BuTMdOaF4mgZMQwI2SFNknKZbFkIAEHhCorlbq1+7yFAENkKfwefOHCKTf4hv+oSL4sRKQwDcJqN9vgvM2CZyAQPSbf7panaAxVi6CBsjKrWfZJSABCUhAAhKQgAQksBgBDZDFGsziSkACEpCABCQgAQlIYGUCGiArt55ll4AEJCABCUhAAhKQwGIENEAWazCLKwEJSEACEpCABCQggZUJaICs3HqWXQISkIAEJCABCUhAAosR0ABZrMEsrgQkIAEJSEACEpCABFYmoAGycutZdglIQAISkIAEJCABCSxGQANksQazuBKQgAQkIAEJSEACEliZgAbIyq1n2SUgAQlIQAISkIAEJLAYAQ2QxRrM4kpAAhKQgAQkIAEJSGBlAhogK7eeZZeABCQgAQlIQAISkMBiBDRAFmswiysBCUhAAhKQgAQkIIGVCWiArNx6ll0CEpCABCQgAQlIQAKLEdAAWazBLK4EJCABCUhAAhKQgARWJqABsnLrWXYJSEACEpCABCQgAQksRkADZLEGs7gSkIAEJCABCUhAAhJYmYAGyMqtZ9klIAEJSEACEpCABCSwGAENkMUazOJKQAISkIAEJCABCUhgZQIaICu3nmWXgAQkIAEJSEACEpDAYgQ0QBZrMIsrAQlIQAISkIAEJCCBlQlogKzcepZdAhKQgAQkIAEJSEACixHQAFmswSyuBCQgAQlIQAISkIAEViagAbJy61l2CUhAAhKQgAQkIAEJLEZAA2SxBrO4EpCABCQgAQlIQAISWJmABsjKrWfZJSABCUhAAhKQgAQksBgBDZDFGsziSkACEpCABCQgAQlIYGUCGiArt55ll4AEJCABCUhAAhKQwGIENEAWazCLKwEJSEACEpCABCQggZUJaICs3HqWXQISkIAEJCABCUhAAosR0ABZrMEsrgQkIAEJSEACEpCABFYmoAGycutZdglIQAISkIAEJCABCSxGQANksQazuBKQgAQkIAEJSEACEliZgAbIyq1n2SUgAQlIQAISkIAEJLAYAQ2QxRrM4kpAAhKQgAQkIAEJSGBlAhogK7eeZZeABCQgAQlIQAISkMBiBDRAFmswiysBCUhAAhKQgAQkIIGVCWiArNx6ll0CEpCABCQgAQlIQAKLEdAAWazBLK4EJCABCUhAAhKQgARWJqABsnLrWXYJSEACEpCABCQgAQksRkADZLEGs7gSkIAEJCABCUhAAhJYmYAGyMqtZ9klIAEJSEACEpCABCSwGAENkMUazOJKQAISkIAEJCABCUhgZQIaICu3nmWXgAQkIAEJSEACEpDAYgQ0QBZrMIsrAQlIQAISkIAEJCCBlQlogKzcepZdAhKQgAQkIAEJSEACixHQAFmswSyuBCQgAQlIQAISkIAEViagAbJy652j7OlD/3uOolgKCUjgIAH1exCYl0vgRATU74kaw6IcI6ABcoyXV/+RwF++vr7+9evr6z+/vr7+RzgSkMBSBP7l6+srGv4v9btUu1lYCYQA+s3710VA+8RyBDRAlmuyUxX4334PghkA/3aqklkYCUjgEYHo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&quot;); background-size: 800px 222.339px;">
        <h1 class="title">CPPRaft系列-raft算法主要流程函数实现-03</h1>
        <div class="group-info">
            <a href="https://wx.zsxq.com/dweb2/index/group/88511825151142">
                <span>来自：</span>
                <span class="group-name">代码随想录</span>
            </a>
        </div>
        <div class="author-info">
            <div class="author">
                <img src="./CPPRaft系列-raft算法主要流程函数实现-03_files/FgTbimn1Oo952em4DBScoknjuuI7" alt="用户头像">
                <span class="nick-name">思无邪</span>
            </div>
            <span class="date" id="article-date">2023年12月24日 21:25</span>
        </div>
        <div class="ql-snow">
            <div class="content ql-editor"><p><br></p><p><span style="font-size: 1.5em; font-family: PingFangSC-Regular;">raft算法主要流程函数实现</span></p><p><br></p><p>本节主要讲解raft算法的关键函数实现。</p><blockquote><div class="blockquote-item">开篇之前先到其他部分学习下 快照snapshot 的概念。</div><div class="blockquote-item">终于可以见到代码了，代码仓库件文末 【后期内容预告！】部分</div></blockquote><h3>raft类的定义</h3><p><br></p><p>重点关注成员变量的作用，成员函数很多都是辅助功能，重点的函数会在后面详细讲解的。</p><p><br></p><p>无注释版</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-keyword">class</span> <span class="ql-token hljs-title">Raft</span> :</div><div class="ql-code-block">{</div><div class="ql-code-block"><span class="ql-token hljs-keyword">private</span>:</div><div class="ql-code-block">    std::mutex m_mtx;</div><div class="ql-code-block">    std::vector&lt;std::shared_ptr&lt; RaftRpc &gt;&gt; m_peers; </div><div class="ql-code-block">    std::shared_ptr&lt;Persister&gt; m_persister;  </div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_me;             </div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_currentTerm;   </div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_votedFor;       </div><div class="ql-code-block">    std::vector&lt;mprrpc:: LogEntry&gt; m_logs; </div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_commitIndex;</div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_lastApplied; </div><div class="ql-code-block">    std::vector&lt;<span class="ql-token hljs-type">int</span>&gt; m_nextIndex; </div><div class="ql-code-block">    std::vector&lt;<span class="ql-token hljs-type">int</span>&gt; m_matchIndex;</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">enum</span> <span class="ql-token hljs-title">Status</span></div><div class="ql-code-block">    {</div><div class="ql-code-block">        Follower,</div><div class="ql-code-block">        Candidate,</div><div class="ql-code-block">        Leader</div><div class="ql-code-block">    };</div><div class="ql-code-block">    <span class="ql-token hljs-comment">// 身份</span></div><div class="ql-code-block">    Status m_status;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyChan  ;    </div><div class="ql-code-block"><br></div><div class="ql-code-block">    std::chrono::_V2::system_clock::time_point m_lastResetElectionTime;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    std::chrono::_V2::system_clock::time_point m_lastResetHearBeatTime;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_lastSnapshotIncludeIndex;</div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> m_lastSnapshotIncludeTerm;</div><div class="ql-code-block"><br></div><div class="ql-code-block"><span class="ql-token hljs-keyword">public</span>:</div><div class="ql-code-block">    <span class="ql-token hljs-function">void AppendEntries1(const mprrpc::AppendEntriesArgs *args, mprrpc::AppendEntriesReply *reply)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void applierTicker()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">bool CondInstallSnapshot(int lastIncludedTerm, int lastIncludedIndex, std::string snapshot)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void doElection()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void doHeartBeat()</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    </div><div class="ql-code-block">    <span class="ql-token hljs-function">void electionTimeOutTicker()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">std::vector&lt;ApplyMsg&gt; getApplyLogs()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">int getNewCommandIndex()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void getPrevLogInfo(int server, int *preIndex, int *preTerm)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void GetState(int *term, bool *isLeader)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void InstallSnapshot( const mprrpc::InstallSnapshotRequest *args, mprrpc::InstallSnapshotResponse *reply)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void leaderHearBeatTicker()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void leaderSendSnapShot(int server)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void leaderUpdateCommitIndex()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">bool matchLog(int logIndex, int logTerm)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void persist()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void RequestVote(const mprrpc::RequestVoteArgs *args, mprrpc::RequestVoteReply *reply)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">bool UpToDate(int index, int term)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">int getLastLogIndex()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void getLastLogIndexAndTerm(int *lastLogIndex, int *lastLogTerm)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">int getLogTermFromLogIndex(int logIndex)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">int GetRaftStateSize()</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">int getSlicesIndexFromLogIndex(int logIndex)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">bool sendRequestVote(int server , std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; args ,  std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; reply,   std::shared_ptr&lt;int&gt; votedNum) </span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">bool sendAppendEntries(int server ,std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; args , std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; reply , std::shared_ptr&lt;int&gt; appendNums ) </span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">void pushMsgToKvServer(ApplyMsg msg)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">void readPersist(std::string data)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-function">std::string persistData()</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">void Start(Op command,int* newLogIndex,int* newLogTerm,bool* isLeader ) </span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">void Snapshot(int index , std::string snapshot )</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block"><span class="ql-token hljs-keyword">public</span>:</div><div class="ql-code-block">    <span class="ql-token hljs-function">void init(std::vector&lt;std::shared_ptr&lt; RaftRpc &gt;&gt; peers,int me,std::shared_ptr&lt;Persister&gt; persister,std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyCh)</span>;</div><div class="ql-code-block"><br></div></div><p><br></p><p><br></p><p>带注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block">class Raft :</div><div class="ql-code-block">{</div><div class="ql-code-block">private:</div><div class="ql-code-block">    std::mutex m_mtx;</div><div class="ql-code-block">    std::vector&lt;std::shared_ptr&lt; RaftRpc &gt;&gt; m_peers; //需要与其他raft节点通信，这里保存与其他结点通信的rpc入口</div><div class="ql-code-block">    std::shared_ptr&lt;Persister&gt; m_persister;   //持久化层，负责raft数据的持久化</div><div class="ql-code-block">    int m_me;             //raft是以集群启动，这个用来标识自己的的编号</div><div class="ql-code-block">    int m_currentTerm;    //记录当前的term</div><div class="ql-code-block">    int m_votedFor;       //记录当前term给谁投票过</div><div class="ql-code-block">    std::vector&lt;mprrpc:: LogEntry&gt; m_logs; //// 日志条目数组，包含了状态机要执行的指令集，以及收到领导时的任期号</div><div class="ql-code-block">    // 这两个状态所有结点都在维护，易失</div><div class="ql-code-block">    int m_commitIndex;</div><div class="ql-code-block">    int m_lastApplied; // 已经汇报给状态机（上层应用）的log 的index</div><div class="ql-code-block"><br></div><div class="ql-code-block">    // 这两个状态是由leader来维护，易失 ，这两个部分在内容补充的部分也会再讲解</div><div class="ql-code-block">    std::vector&lt;int&gt; m_nextIndex; // 这两个状态的下标1开始，因为通常commitIndex和lastApplied从0开始，应该是一个无效的index，因此下标从1开始</div><div class="ql-code-block">    std::vector&lt;int&gt; m_matchIndex;</div><div class="ql-code-block">    enum Status</div><div class="ql-code-block">    {</div><div class="ql-code-block">        Follower,</div><div class="ql-code-block">        Candidate,</div><div class="ql-code-block">        Leader</div><div class="ql-code-block">    };</div><div class="ql-code-block">    // 保存当前身份</div><div class="ql-code-block">    Status m_status;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyChan;     // client从这里取日志，client与raft通信的接口</div><div class="ql-code-block">    // ApplyMsgQueue chan ApplyMsg // raft内部使用的chan，applyChan是用于和服务层交互，最后好像没用上</div><div class="ql-code-block">	</div><div class="ql-code-block">    // 选举超时</div><div class="ql-code-block">    std::chrono::_V2::system_clock::time_point m_lastResetElectionTime;</div><div class="ql-code-block">    // 心跳超时，用于leader</div><div class="ql-code-block">    std::chrono::_V2::system_clock::time_point m_lastResetHearBeatTime;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    // 用于传入快照点</div><div class="ql-code-block">    // 储存了快照中的最后一个日志的Index和Term</div><div class="ql-code-block">    int m_lastSnapshotIncludeIndex;</div><div class="ql-code-block">    int m_lastSnapshotIncludeTerm;</div><div class="ql-code-block"><br></div><div class="ql-code-block">public:</div><div class="ql-code-block">    </div><div class="ql-code-block">    void AppendEntries1(const mprrpc::AppendEntriesArgs *args, mprrpc::AppendEntriesReply *reply); //日志同步 + 心跳 rpc ，重点关注</div><div class="ql-code-block">    void applierTicker();     //定期向状态机写入日志，非重点函数</div><div class="ql-code-block">    </div><div class="ql-code-block">    bool CondInstallSnapshot(int lastIncludedTerm, int lastIncludedIndex, std::string snapshot);    //快照相关，非重点</div><div class="ql-code-block">    void doElection();    //发起选举</div><div class="ql-code-block">    void doHeartBeat();    //leader定时发起心跳</div><div class="ql-code-block">    // 每隔一段时间检查睡眠时间内有没有重置定时器，没有则说明超时了</div><div class="ql-code-block">// 如果有则设置合适睡眠时间：睡眠到重置时间+超时时间</div><div class="ql-code-block">    void electionTimeOutTicker();   //监控是否该发起选举了</div><div class="ql-code-block">    std::vector&lt;ApplyMsg&gt; getApplyLogs();</div><div class="ql-code-block">    int getNewCommandIndex();</div><div class="ql-code-block">    void getPrevLogInfo(int server, int *preIndex, int *preTerm);</div><div class="ql-code-block">    void GetState(int *term, bool *isLeader);  //看当前节点是否是leader</div><div class="ql-code-block">    void InstallSnapshot( const mprrpc::InstallSnapshotRequest *args, mprrpc::InstallSnapshotResponse *reply);  </div><div class="ql-code-block">    void leaderHearBeatTicker(); //检查是否需要发起心跳（leader）</div><div class="ql-code-block">    void leaderSendSnapShot(int server);  </div><div class="ql-code-block">    void leaderUpdateCommitIndex();  //leader更新commitIndex</div><div class="ql-code-block">    bool matchLog(int logIndex, int logTerm);  //对应Index的日志是否匹配，只需要Index和Term就可以知道是否匹配</div><div class="ql-code-block">    void persist();   //持久化</div><div class="ql-code-block">    void RequestVote(const mprrpc::RequestVoteArgs *args, mprrpc::RequestVoteReply *reply);    //变成candidate之后需要让其他结点给自己投票</div><div class="ql-code-block">    bool UpToDate(int index, int term);   //判断当前节点是否含有最新的日志</div><div class="ql-code-block">    int getLastLogIndex();</div><div class="ql-code-block">    void getLastLogIndexAndTerm(int *lastLogIndex, int *lastLogTerm);</div><div class="ql-code-block">    int getLogTermFromLogIndex(int logIndex);</div><div class="ql-code-block">    int GetRaftStateSize();</div><div class="ql-code-block">    int getSlicesIndexFromLogIndex(int logIndex);   //设计快照之后logIndex不能与在日志中的数组下标相等了，根据logIndex找到其在日志数组中的位置</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    bool sendRequestVote(int server , std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; args ,  std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; reply,   std::shared_ptr&lt;int&gt; votedNum) ; // 请求其他结点的投票</div><div class="ql-code-block">    bool sendAppendEntries(int server ,std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; args , std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; reply , std::shared_ptr&lt;int&gt; appendNums ) ;  //Leader发送心跳后，对心跳的回复进行对应的处理</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    //rf.applyChan &lt;- msg //不拿锁执行  可以单独创建一个线程执行，但是为了同意使用std:thread ，避免使用pthread_create，因此专门写一个函数来执行</div><div class="ql-code-block">    void pushMsgToKvServer(ApplyMsg msg);  //给上层的kvserver层发送消息</div><div class="ql-code-block">    void readPersist(std::string data);    </div><div class="ql-code-block">    std::string persistData();</div><div class="ql-code-block">    void Start(Op command,int* newLogIndex,int* newLogTerm,bool* isLeader ) ;   // 发布发来一个新日志</div><div class="ql-code-block">// 即kv-server主动发起，请求raft（持久层）保存snapshot里面的数据，index是用来表示snapshot快照执行到了哪条命令</div><div class="ql-code-block">    void Snapshot(int index , std::string snapshot );</div><div class="ql-code-block"><br></div><div class="ql-code-block">public:</div><div class="ql-code-block">    void init(std::vector&lt;std::shared_ptr&lt; RaftRpc &gt;&gt; peers,int me,std::shared_ptr&lt;Persister&gt; persister,std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyCh);		//初始化</div><div class="ql-code-block"><br></div></div><p><br></p><p>看到这么多函数说实话人都麻了，那梳理一下吧。</p><p><br></p><p>对于这么多函数其实需要关注的并不多，重点需要关注的：</p><p><br></p><ol><li data-list="bullet"><span class="ql-ui"></span>Raft的主要流程：领导选举（<code>sendRequestVote RequestVote</code> ） 日志同步、心跳（<code>sendAppendEntries</code>  <code>AppendEntries</code> ）</li><li data-list="bullet"><span class="ql-ui"></span>定时器的维护：主要包括raft向状态机定时写入（<code>applierTicker</code> ）、心跳维护定时器（<code>leaderHearBeatTicker</code> ）、选举超时定时器（<code>electionTimeOutTicker</code> ）。</li></ol><p><br></p><ol><li data-list="bullet"><span class="ql-ui"></span>持久化相关：包括哪些内容需要持久化，什么时候需要持久化（persist）</li></ol><p><br></p><p>这样看起来关键的就是只有几个函数了。</p><blockquote><div class="blockquote-item">需要再次说明的是，本系列的作用是帮助快速理解raft，但是无法代替思考。比如raft在各种情况下的故障如何保证正确性需要自行多多思考。</div></blockquote><p><br></p><h3>启动初始化</h3><p><br></p><p>无注释版本：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::init(std::vector&lt;std::shared_ptr&lt;RaftRpc&gt;&gt; peers, int me, std::shared_ptr&lt;Persister&gt; persister, std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyCh) </span>{</div><div class="ql-code-block">    m_peers = peers;  </div><div class="ql-code-block">    m_persister = persister;</div><div class="ql-code-block">    m_me = me;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_mtx.<span class="ql-token hljs-built_in">lock</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//applier</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">this</span>-&gt;applyChan = applyCh;</div><div class="ql-code-block"><span class="ql-token hljs-comment">//    rf.ApplyMsgQueue = make(chan ApplyMsg)</span></div><div class="ql-code-block">    m_currentTerm = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_status = Follower;</div><div class="ql-code-block">    m_commitIndex = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_lastApplied = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_logs.<span class="ql-token hljs-built_in">clear</span>();</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i =<span class="ql-token hljs-number">0</span>;i&lt;m_peers.<span class="ql-token hljs-built_in">size</span>();i++){</div><div class="ql-code-block">        m_matchIndex.<span class="ql-token hljs-built_in">push_back</span>(<span class="ql-token hljs-number">0</span>);</div><div class="ql-code-block">        m_nextIndex.<span class="ql-token hljs-built_in">push_back</span>(<span class="ql-token hljs-number">0</span>);</div><div class="ql-code-block">    }</div><div class="ql-code-block">    m_votedFor = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_lastSnapshotIncludeIndex =<span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_lastSnapshotIncludeTerm = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">    m_lastResetHearBeatTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// initialize from state persisted before a crash</span></div><div class="ql-code-block">    <span class="ql-token hljs-built_in">readPersist</span>(m_persister-&gt;<span class="ql-token hljs-built_in">ReadRaftState</span>());</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(m_lastSnapshotIncludeIndex &gt; <span class="ql-token hljs-number">0</span>){</div><div class="ql-code-block">        m_lastApplied = m_lastSnapshotIncludeIndex;</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//rf.commitIndex = rf.lastSnapshotIncludeIndex   todo ：崩溃恢复为何不能读取commitIndex</span></div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_mtx.<span class="ql-token hljs-built_in">unlock</span>();</div><div class="ql-code-block">    <span class="ql-token hljs-comment">// start ticker goroutine to start elections</span></div><div class="ql-code-block">    <span class="ql-token hljs-function">std::thread t(&amp;Raft::leaderHearBeatTicker, this)</span>;</div><div class="ql-code-block">    t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">std::thread t2(&amp;Raft::electionTimeOutTicker, this)</span>;</div><div class="ql-code-block">    t2.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">std::thread t3(&amp;Raft::applierTicker, this)</span>;</div><div class="ql-code-block">    t3.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p>带注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::init(std::vector&lt;std::shared_ptr&lt;RaftRpc&gt;&gt; peers, int me, std::shared_ptr&lt;Persister&gt; persister, std::shared_ptr&lt;LockQueue&lt;ApplyMsg&gt;&gt; applyCh) </span>{</div><div class="ql-code-block">    m_peers = peers;     <span class="ql-token hljs-comment">//与其他结点沟通的rpc类</span></div><div class="ql-code-block">    m_persister = persister;   <span class="ql-token hljs-comment">//持久化类</span></div><div class="ql-code-block">    m_me = me;    <span class="ql-token hljs-comment">//标记自己，毕竟不能给自己发送rpc吧</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_mtx.<span class="ql-token hljs-built_in">lock</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//applier</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">this</span>-&gt;applyChan = applyCh;   <span class="ql-token hljs-comment">//与kv-server沟通</span></div><div class="ql-code-block"><span class="ql-token hljs-comment">//    rf.ApplyMsgQueue = make(chan ApplyMsg)</span></div><div class="ql-code-block">    m_currentTerm = <span class="ql-token hljs-number">0</span>;   <span class="ql-token hljs-comment">//初始化term为0</span></div><div class="ql-code-block">    m_status = Follower;   <span class="ql-token hljs-comment">//初始化身份为follower</span></div><div class="ql-code-block">    m_commitIndex = <span class="ql-token hljs-number">0</span>;  </div><div class="ql-code-block">    m_lastApplied = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_logs.<span class="ql-token hljs-built_in">clear</span>();</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i =<span class="ql-token hljs-number">0</span>;i&lt;m_peers.<span class="ql-token hljs-built_in">size</span>();i++){</div><div class="ql-code-block">        m_matchIndex.<span class="ql-token hljs-built_in">push_back</span>(<span class="ql-token hljs-number">0</span>);</div><div class="ql-code-block">        m_nextIndex.<span class="ql-token hljs-built_in">push_back</span>(<span class="ql-token hljs-number">0</span>);</div><div class="ql-code-block">    }</div><div class="ql-code-block">    m_votedFor = <span class="ql-token hljs-number">-1</span>;    <span class="ql-token hljs-comment">//当前term没有给其他人投过票就用-1表示</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_lastSnapshotIncludeIndex = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_lastSnapshotIncludeTerm = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block">    m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">    m_lastResetHearBeatTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// initialize from state persisted before a crash</span></div><div class="ql-code-block">    <span class="ql-token hljs-built_in">readPersist</span>(m_persister-&gt;<span class="ql-token hljs-built_in">ReadRaftState</span>());</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(m_lastSnapshotIncludeIndex &gt; <span class="ql-token hljs-number">0</span>){</div><div class="ql-code-block">        m_lastApplied = m_lastSnapshotIncludeIndex;</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//rf.commitIndex = rf.lastSnapshotIncludeIndex 崩溃恢复不能读取commitIndex</span></div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_mtx.<span class="ql-token hljs-built_in">unlock</span>();</div><div class="ql-code-block">    <span class="ql-token hljs-comment">// start ticker  开始三个定时器</span></div><div class="ql-code-block">    <span class="ql-token hljs-function">std::thread t(&amp;Raft::leaderHearBeatTicker, this)</span>;</div><div class="ql-code-block">    t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">std::thread t2(&amp;Raft::electionTimeOutTicker, this)</span>;</div><div class="ql-code-block">    t2.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">std::thread t3(&amp;Raft::applierTicker, this)</span>;</div><div class="ql-code-block">    t3.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">}</div></div><p><br></p><p>从上面可以看到一共产生了三个定时器，分别维护：选举、日志同步和心跳、raft节点与kv-server的联系。相互之间是比较隔离的。</p><p><br></p><h3>选leader</h3><p><br></p><p>主要涉及函数及其流程：</p><p><br></p><p><img src="./CPPRaft系列-raft算法主要流程函数实现-03_files/FjzFfi6jY-SnRVKFrYXoDaKPSNry"></p><p><br></p><p><br></p><p><strong>electionTimeOutTicker</strong>：负责查看是否该发起选举，如果该发起选举就执行doElection发起选举。</p><p><br></p><p><strong>doElection</strong>：实际发起选举，构造需要发送的rpc，并多线程调用sendRequestVote处理rpc及其相应。</p><p><br></p><p><strong>sendRequestVote</strong>：负责发送选举中的RPC，在发送完rpc后还需要负责接收并处理对端发送回来的响应。</p><p><br></p><p><strong>RequestVote</strong>：接收别人发来的选举请求，主要检验是否要给对方投票。</p><p><br></p><p><br></p><h4><strong>electionTimeOutTicker</strong>:</h4><p><br></p><p>选举超时由于<code>electionTimeOutTicker</code> 维护。</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block">void Raft::electionTimeOutTicker() {</div><div class="ql-code-block">    // Check if a Leader election should be started.</div><div class="ql-code-block">    while (true) {</div><div class="ql-code-block">        m_mtx.lock();</div><div class="ql-code-block">        auto nowTime = now(); //睡眠前记录时间</div><div class="ql-code-block">        auto suitableSleepTime = getRandomizedElectionTimeout() + m_lastResetElectionTime - nowTime;</div><div class="ql-code-block">        m_mtx.unlock();</div><div class="ql-code-block">        if (suitableSleepTime.count() &gt; 1) {</div><div class="ql-code-block">            std::this_thread::sleep_for(suitableSleepTime);</div><div class="ql-code-block">        }</div><div class="ql-code-block"><br></div><div class="ql-code-block">        if ((m_lastResetElectionTime - nowTime).count() &gt; 0) {  //说明睡眠的这段时间有重置定时器，那么就没有超时，再次睡眠</div><div class="ql-code-block">            continue;</div><div class="ql-code-block">        }</div><div class="ql-code-block">        doElection();</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div></div><p><br></p><p>在死循环中，首先计算距离下一次超时应该睡眠的时间suitableSleepTime，然后睡眠这段时间，醒来后查看睡眠的这段时间选举超时定时器是否被触发，如果没有触发就发起选举。</p><p><br></p><blockquote><div class="blockquote-item">“举超时定时器是否被触发”：选举定时器的触发条件：收到leader发来的appendEntryRPC 、给其他的节点选举投票</div></blockquote><p><br></p><p>在死循环中，首先计算距离上次重置选举计时器的时间加上随机化的选举超时时间，然后线程根据这个时间决定是否睡眠。若超时时间未到，线程进入睡眠状态，若在此期间选举计时器被重置，则继续循环。若超时时间已到，调用<code>doElection()</code> 函数启动领导者选举过程。</p><p><br></p><h4><strong>doElection</strong> ：</h4><p><br></p><p>无注释版</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::doElection() </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; g(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_status != Leader) {</div><div class="ql-code-block">        </div><div class="ql-code-block">        m_status = Candidate;</div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_currentTerm += <span class="ql-token hljs-number">1</span>;</div><div class="ql-code-block">        m_votedFor = m_me; </div><div class="ql-code-block">        <span class="ql-token hljs-built_in">persist</span>();</div><div class="ql-code-block">        std::shared_ptr&lt;<span class="ql-token hljs-type">int</span>&gt; votedNum = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;<span class="ql-token hljs-type">int</span>&gt;(<span class="ql-token hljs-number">1</span>); </div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt; m_peers.<span class="ql-token hljs-built_in">size</span>(); i++) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (i == m_me) {</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> lastLogIndex = <span class="ql-token hljs-number">-1</span>, lastLogTerm = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">            <span class="ql-token hljs-built_in">getLastLogIndexAndTerm</span>(&amp;lastLogIndex, &amp;lastLogTerm);<span class="ql-token hljs-comment">//获取最后一个log的term和下标</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">            std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; requestVoteArgs = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::RequestVoteArgs&gt;();</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_candidateid</span>(m_me);</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_lastlogindex</span>(lastLogIndex);</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_lastlogterm</span>(lastLogTerm);</div><div class="ql-code-block">            std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; requestVoteReply = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::RequestVoteReply&gt;();</div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-function">std::thread t(&amp;Raft::sendRequestVote, this, i, requestVoteArgs, requestVoteReply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                          votedNum)</span>; </div><div class="ql-code-block">            t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">        }</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p>带注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::doElection() </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; g(m_mtx)</span>; <span class="ql-token hljs-comment">//c11新特性，使用raii避免死锁</span></div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_status != Leader) {</div><div class="ql-code-block">        <span class="ql-token hljs-built_in">DPrintf</span>(<span class="ql-token hljs-string">"[       ticker-func-rf(%d)              ]  选举定时器到期且不是leader，开始选举 \n"</span>, m_me);</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//当选举的时候定时器超时就必须重新选举，不然没有选票就会一直卡住</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//重竞选超时，term也会增加的</span></div><div class="ql-code-block">        m_status = Candidate;</div><div class="ql-code-block">        <span class="ql-token hljs-comment">///开始新一轮的选举</span></div><div class="ql-code-block">        m_currentTerm += <span class="ql-token hljs-number">1</span>;  <span class="ql-token hljs-comment">//无论是刚开始竞选，还是超时重新竞选，term都要增加</span></div><div class="ql-code-block">        m_votedFor = m_me; <span class="ql-token hljs-comment">//即是自己给自己投票，也避免candidate给同辈的candidate投</span></div><div class="ql-code-block">        <span class="ql-token hljs-built_in">persist</span>();   </div><div class="ql-code-block">        std::shared_ptr&lt;<span class="ql-token hljs-type">int</span>&gt; votedNum = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;<span class="ql-token hljs-type">int</span>&gt;(<span class="ql-token hljs-number">1</span>); <span class="ql-token hljs-comment">// 使用 make_shared 函数初始化 !! 亮点</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//	重新设置定时器</span></div><div class="ql-code-block">        m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//	发布RequestVote RPC</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt; m_peers.<span class="ql-token hljs-built_in">size</span>(); i++) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (i == m_me) {</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> lastLogIndex = <span class="ql-token hljs-number">-1</span>, lastLogTerm = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">            <span class="ql-token hljs-built_in">getLastLogIndexAndTerm</span>(&amp;lastLogIndex, &amp;lastLogTerm);<span class="ql-token hljs-comment">//获取最后一个log的term和下标，以添加到RPC的发送</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//初始化发送参数</span></div><div class="ql-code-block">            std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; requestVoteArgs = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::RequestVoteArgs&gt;();</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_candidateid</span>(m_me);</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_lastlogindex</span>(lastLogIndex);</div><div class="ql-code-block">            requestVoteArgs-&gt;<span class="ql-token hljs-built_in">set_lastlogterm</span>(lastLogTerm);</div><div class="ql-code-block">            std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; requestVoteReply = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::RequestVoteReply&gt;();</div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//使用匿名函数执行避免其拿到锁</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-function">std::thread t(&amp;Raft::sendRequestVote, this, i, requestVoteArgs, requestVoteReply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                          votedNum)</span>; <span class="ql-token hljs-comment">// 创建新线程并执行函数，并传递参数</span></div><div class="ql-code-block">            t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">        }</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div></div><p><br></p><h4><strong>sendRequestVote</strong>：</h4><p>无注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">bool Raft::sendRequestVote(int server, std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; args, std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; reply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                           std::shared_ptr&lt;int&gt; votedNum) </span>{</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">auto</span> start = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="ql-token hljs-built_in">RequestVote</span>(args.<span class="ql-token hljs-built_in">get</span>(),reply.<span class="ql-token hljs-built_in">get</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!ok) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; lg(m_mtx)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(reply-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm){</div><div class="ql-code-block">        m_status = Follower; <span class="ql-token hljs-comment">//三变：身份，term，和投票</span></div><div class="ql-code-block">        m_currentTerm = reply-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">        <span class="ql-token hljs-built_in">persist</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> <span class="ql-token hljs-keyword">if</span> ( reply-&gt;<span class="ql-token hljs-built_in">term</span>()   &lt; m_currentTerm   ) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(!reply-&gt;<span class="ql-token hljs-built_in">votegranted</span>()){</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    *votedNum = *votedNum + <span class="ql-token hljs-number">1</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (*votedNum &gt;=  m_peers.<span class="ql-token hljs-built_in">size</span>()/<span class="ql-token hljs-number">2</span>+<span class="ql-token hljs-number">1</span>) {</div><div class="ql-code-block">        *votedNum = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_status = Leader;</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-type">int</span> lastLogIndex =   <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt;m_nextIndex.<span class="ql-token hljs-built_in">size</span>()  ; i++) {</div><div class="ql-code-block">            m_nextIndex[i] = lastLogIndex + <span class="ql-token hljs-number">1</span> ;</div><div class="ql-code-block">            m_matchIndex[i] = <span class="ql-token hljs-number">0</span>;     </div><div class="ql-code-block">        }</div><div class="ql-code-block">        <span class="ql-token hljs-function">std::thread t(&amp;Raft::doHeartBeat, this)</span>; </div><div class="ql-code-block">        t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-built_in">persist</span>();</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">}</div></div><p>带注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">bool Raft::sendRequestVote(int server, std::shared_ptr&lt;mprrpc::RequestVoteArgs&gt; args, std::shared_ptr&lt;mprrpc::RequestVoteReply&gt; reply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                           std::shared_ptr&lt;int&gt; votedNum) </span>{</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="ql-token hljs-built_in">RequestVote</span>(args.<span class="ql-token hljs-built_in">get</span>(),reply.<span class="ql-token hljs-built_in">get</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!ok) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;<span class="ql-token hljs-comment">//rpc通信失败就立即返回，避免资源消耗</span></div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; lg(m_mtx)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(reply-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm){</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//回复的term比自己大，说明自己落后了，那么就更新自己的状态并且退出</span></div><div class="ql-code-block">        m_status = Follower; <span class="ql-token hljs-comment">//三变：身份，term，和投票</span></div><div class="ql-code-block">        m_currentTerm = reply-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>;  <span class="ql-token hljs-comment">//term更新了，那么这个term自己肯定没投过票，为-1</span></div><div class="ql-code-block">        <span class="ql-token hljs-built_in">persist</span>(); <span class="ql-token hljs-comment">//持久化</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> <span class="ql-token hljs-keyword">if</span> ( reply-&gt;<span class="ql-token hljs-built_in">term</span>()   &lt; m_currentTerm   ) {</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//回复的term比自己的term小，不应该出现这种情况</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(!reply-&gt;<span class="ql-token hljs-built_in">votegranted</span>()){  <span class="ql-token hljs-comment">//这个节点因为某些原因没给自己投票，没啥好说的，结束本函数</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block">  <span class="ql-token hljs-comment">//给自己投票了</span></div><div class="ql-code-block">    *votedNum = *votedNum + <span class="ql-token hljs-number">1</span>; <span class="ql-token hljs-comment">//voteNum多一个</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (*votedNum &gt;=  m_peers.<span class="ql-token hljs-built_in">size</span>()/<span class="ql-token hljs-number">2</span>+<span class="ql-token hljs-number">1</span>) {</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//变成leader</span></div><div class="ql-code-block">        *votedNum = <span class="ql-token hljs-number">0</span>;   <span class="ql-token hljs-comment">//重置voteDNum，如果不重置，那么就会变成leader很多次，是没有必要的，甚至是错误的！！！</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//	第一次变成leader，初始化状态和nextIndex、matchIndex</span></div><div class="ql-code-block">        m_status = Leader;</div><div class="ql-code-block">        <span class="ql-token hljs-type">int</span> lastLogIndex =   <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt;m_nextIndex.<span class="ql-token hljs-built_in">size</span>()  ; i++) {</div><div class="ql-code-block">            m_nextIndex[i] = lastLogIndex + <span class="ql-token hljs-number">1</span> ;<span class="ql-token hljs-comment">//有效下标从1开始，因此要+1</span></div><div class="ql-code-block">            m_matchIndex[i] = <span class="ql-token hljs-number">0</span>;               <span class="ql-token hljs-comment">//每换一个领导都是从0开始，见论文的fig2</span></div><div class="ql-code-block">        }</div><div class="ql-code-block">        <span class="ql-token hljs-function">std::thread t(&amp;Raft::doHeartBeat, this)</span>; <span class="ql-token hljs-comment">//马上向其他节点宣告自己就是leader</span></div><div class="ql-code-block">        t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-built_in">persist</span>();  </div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">return</span> <span class="ql-token hljs-literal">true</span>;</div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p>只有leader才需要维护<code>m_nextIndex和m_matchIndex</code> 。</p><p><br></p><h4><strong>RequestVote</strong>：</h4><p><br></p><p>无注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::RequestVote( const mprrpc::RequestVoteArgs *args, mprrpc::RequestVoteReply *reply) </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; lg(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">Defer ec1([this]() -&gt; void { //应该先持久化，再撤销lock</span></div><div class="ql-code-block"><span class="ql-token hljs-function">        this-&gt;persist();</span></div><div class="ql-code-block"><span class="ql-token hljs-function">    })</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    </div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &lt; m_currentTerm) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Expire);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_status = Follower;</div><div class="ql-code-block">        m_currentTerm = args-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> lastLogTerm = <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!<span class="ql-token hljs-built_in">UpToDate</span>(args-&gt;<span class="ql-token hljs-built_in">lastlogindex</span>(), args-&gt;<span class="ql-token hljs-built_in">lastlogterm</span>())) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Voted);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_votedFor != <span class="ql-token hljs-number">-1</span> &amp;&amp; m_votedFor != args-&gt;<span class="ql-token hljs-built_in">candidateid</span>()) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Voted);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">        m_votedFor = args-&gt;<span class="ql-token hljs-built_in">candidateid</span>();</div><div class="ql-code-block">        m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">        </div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Normal);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">true</span>);</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p>带注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::RequestVote( const mprrpc::RequestVoteArgs *args, mprrpc::RequestVoteReply *reply) </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; lg(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">Defer ec1([this]() -&gt; void { //应该先持久化，再撤销lock，因此这个写在lock后面</span></div><div class="ql-code-block"><span class="ql-token hljs-function">        this-&gt;persist();</span></div><div class="ql-code-block"><span class="ql-token hljs-function">    })</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-comment">//对args的term的三种情况分别进行处理，大于小于等于自己的term都是不同的处理</span></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//reason: 出现网络分区，该竞选者已经OutOfDate(过时）</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &lt; m_currentTerm) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Expire);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-comment">//论文fig2:右下角，如果任何时候rpc请求或者响应的term大于自己的term，更新term，并变成follower</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_status = Follower;</div><div class="ql-code-block">        m_currentTerm = args-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//	重置定时器：收到leader的ae，开始选举，透出票</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//这时候更新了term之后，votedFor也要置为-1</span></div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//	现在节点任期都是相同的(任期小的也已经更新到新的args的term了)</span></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//	要检查log的term和index是不是匹配的了</span></div><div class="ql-code-block">    <span class="ql-token hljs-type">int</span> lastLogTerm = <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block">    <span class="ql-token hljs-comment">//只有没投票，且candidate的日志的新的程度 ≥ 接受者的日志新的程度 才会授票</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!<span class="ql-token hljs-built_in">UpToDate</span>(args-&gt;<span class="ql-token hljs-built_in">lastlogindex</span>(), args-&gt;<span class="ql-token hljs-built_in">lastlogterm</span>())) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//日志太旧了</span></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Voted);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block">   </div><div class="ql-code-block"><span class="ql-token hljs-comment">//    当因为网络质量不好导致的请求丢失重发就有可能！！！！</span></div><div class="ql-code-block"><span class="ql-token hljs-comment">//    因此需要避免重复投票</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_votedFor != <span class="ql-token hljs-number">-1</span> &amp;&amp; m_votedFor != args-&gt;<span class="ql-token hljs-built_in">candidateid</span>()) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Voted);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//同意投票</span></div><div class="ql-code-block">        m_votedFor = args-&gt;<span class="ql-token hljs-built_in">candidateid</span>();</div><div class="ql-code-block">        m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();<span class="ql-token hljs-comment">//认为必须要在投出票的时候才重置定时器，</span></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votestate</span>(Normal);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_votegranted</span>(<span class="ql-token hljs-literal">true</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p><br></p><p><br></p><h3>日志复制|心跳</h3><p><br></p><p><br></p><p><img src="./CPPRaft系列-raft算法主要流程函数实现-03_files/Fqql9dbJTAJS5EA6pby_AIIw7mVo"></p><p><br></p><blockquote><div class="blockquote-item">可以从流程图看到，函数实现上我尽量将心跳日志复制的流程统一，方便理解和后期统一修改</div><div class="blockquote-item">理解AppendEntry 相关内容，snapshot的逻辑是类似的。</div></blockquote><p><br></p><p><strong>leaderHearBeatTicker</strong>:负责查看是否该发送心跳了，如果该发起就执行doHeartBeat。</p><p><br></p><p><strong>doHeartBeat</strong>:实际发送心跳，判断到底是构造需要发送的rpc，并多线程调用sendRequestVote处理rpc及其相应。</p><p><br></p><p><strong>sendAppendEntries</strong>:负责发送日志的RPC，在发送完rpc后还需要负责接收并处理对端发送回来的响应。</p><p><br></p><p><strong>leaderSendSnapShot</strong>:负责发送快照的RPC，在发送完rpc后还需要负责接收并处理对端发送回来的响应。</p><p><br></p><p><strong>AppendEntries</strong>:接收leader发来的日志请求，主要检验用于检查当前日志是否匹配并同步leader的日志到本机。</p><p><br></p><p><strong>InstallSnapshot</strong>:接收leader发来的快照请求，同步快照到本机。</p><p><br></p><p><br></p><p><br></p><h4>leaderHearBeatTicker:</h4><p><br></p><p>无注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::leaderHearBeatTicker() </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">while</span> (<span class="ql-token hljs-literal">true</span>) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">auto</span> nowTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">        m_mtx.<span class="ql-token hljs-built_in">lock</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">auto</span> suitableSleepTime = std::chrono::<span class="ql-token hljs-built_in">milliseconds</span>(HeartBeatTimeout) + m_lastResetHearBeatTime - nowTime;</div><div class="ql-code-block">        m_mtx.<span class="ql-token hljs-built_in">unlock</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (suitableSleepTime.<span class="ql-token hljs-built_in">count</span>() &lt; <span class="ql-token hljs-number">1</span>) {</div><div class="ql-code-block">            suitableSleepTime = std::chrono::<span class="ql-token hljs-built_in">milliseconds</span>(<span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">        }</div><div class="ql-code-block">        std::this_thread::<span class="ql-token hljs-built_in">sleep_for</span>(suitableSleepTime);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> ((m_lastResetHearBeatTime - nowTime).<span class="ql-token hljs-built_in">count</span>() &gt; <span class="ql-token hljs-number">0</span>) { </div><div class="ql-code-block">            <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">        }</div><div class="ql-code-block">        <span class="ql-token hljs-built_in">doHeartBeat</span>();</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div></div><p><br></p><p>带注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::leaderHearBeatTicker() </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">while</span> (<span class="ql-token hljs-literal">true</span>) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">auto</span> nowTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">        m_mtx.<span class="ql-token hljs-built_in">lock</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">auto</span> suitableSleepTime = std::chrono::<span class="ql-token hljs-built_in">milliseconds</span>(HeartBeatTimeout) + m_lastResetHearBeatTime - nowTime;</div><div class="ql-code-block">        m_mtx.<span class="ql-token hljs-built_in">unlock</span>();</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (suitableSleepTime.<span class="ql-token hljs-built_in">count</span>() &lt; <span class="ql-token hljs-number">1</span>) {</div><div class="ql-code-block">            suitableSleepTime = std::chrono::<span class="ql-token hljs-built_in">milliseconds</span>(<span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">        }</div><div class="ql-code-block">        std::this_thread::<span class="ql-token hljs-built_in">sleep_for</span>(suitableSleepTime);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> ((m_lastResetHearBeatTime - nowTime).<span class="ql-token hljs-built_in">count</span>() &gt; <span class="ql-token hljs-number">0</span>) { <span class="ql-token hljs-comment">//说明睡眠的这段时间有重置定时器，那么就没有超时，再次睡眠</span></div><div class="ql-code-block">            <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">        }</div><div class="ql-code-block">        <span class="ql-token hljs-built_in">doHeartBeat</span>();</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div></div><p><br></p><p>其基本逻辑和选举定时器electionTimeOutTicker一模一样，不一样之处在于设置的休眠时间不同，这里是根据HeartBeatTimeout来设置，而<code>electionTimeOutTicker中是根据getRandomizedElectionTimeout()</code> 设置。</p><p><br></p><h4><strong>doHeartBeat</strong>：</h4><blockquote><div class="blockquote-item">这里目前逻辑写的不统一，发送快照leaderSendSnapShot和发送日志sendAppendEntries的rpc值的构造没有统一，且写在一坨。</div><div class="blockquote-item">可以抽离出来。目前先将就，关注主要逻辑。</div></blockquote><p><br></p><p>无注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::doHeartBeat() </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">std::lock_guard&lt;mutex&gt; g(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_status == Leader) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">auto</span> appendNums = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;<span class="ql-token hljs-type">int</span>&gt;(<span class="ql-token hljs-number">1</span>); <span class="ql-token hljs-comment">//正确返回的节点的数量</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt; m_peers.<span class="ql-token hljs-built_in">size</span>(); i++) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span>(i == m_me){</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (m_nextIndex[i] &lt;= m_lastSnapshotIncludeIndex) {</div><div class="ql-code-block">                <span class="ql-token hljs-function">std::thread t(&amp;Raft::leaderSendSnapShot, this, i)</span>; </div><div class="ql-code-block">                t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> preLogIndex = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> PrevLogTerm = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">            <span class="ql-token hljs-built_in">getPrevLogInfo</span>(i, &amp;preLogIndex, &amp;PrevLogTerm);</div><div class="ql-code-block">            std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; appendEntriesArgs = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::AppendEntriesArgs&gt;();</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_leaderid</span>(m_me);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_prevlogindex</span>(preLogIndex);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_prevlogterm</span>(PrevLogTerm);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">clear_entries</span>();</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_leadercommit</span>(m_commitIndex);</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (preLogIndex != m_lastSnapshotIncludeIndex) {</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> j = <span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(preLogIndex) + <span class="ql-token hljs-number">1</span>; j &lt; m_logs.<span class="ql-token hljs-built_in">size</span>(); ++j) {</div><div class="ql-code-block">                    mprrpc::LogEntry *sendEntryPtr = appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">add_entries</span>();</div><div class="ql-code-block">                    *sendEntryPtr = m_logs[j]; </div><div class="ql-code-block">                }</div><div class="ql-code-block">            } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">const</span> <span class="ql-token hljs-keyword">auto</span>&amp; item: m_logs) {</div><div class="ql-code-block">                    mprrpc::LogEntry *sendEntryPtr = appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">add_entries</span>();</div><div class="ql-code-block">                    *sendEntryPtr = item; </div><div class="ql-code-block">                }</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> lastLogIndex = <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block">            <span class="ql-token hljs-comment">//构造返回值</span></div><div class="ql-code-block">            <span class="ql-token hljs-type">const</span> std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; appendEntriesReply = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::AppendEntriesReply&gt;();</div><div class="ql-code-block">            appendEntriesReply-&gt;<span class="ql-token hljs-built_in">set_appstate</span>(Disconnected);</div><div class="ql-code-block">            <span class="ql-token hljs-function">std::thread t(&amp;Raft::sendAppendEntries, this, i, appendEntriesArgs, appendEntriesReply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                          appendNums)</span>; </div><div class="ql-code-block">            t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">        }</div><div class="ql-code-block">        m_lastResetHearBeatTime = <span class="ql-token hljs-built_in">now</span>();</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div><div class="ql-code-block"><br></div></div><p><br></p><p>带注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::doHeartBeat() </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">std::lock_guard&lt;mutex&gt; g(m_mtx)</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_status == Leader) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">auto</span> appendNums = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;<span class="ql-token hljs-type">int</span>&gt;(<span class="ql-token hljs-number">1</span>); <span class="ql-token hljs-comment">//正确返回的节点的数量</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//对Follower（除了自己外的所有节点发送AE）</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt; m_peers.<span class="ql-token hljs-built_in">size</span>(); i++) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span>(i == m_me){ <span class="ql-token hljs-comment">//不对自己发送AE</span></div><div class="ql-code-block">                <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-comment">//日志压缩加入后要判断是发送快照还是发送AE</span></div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (m_nextIndex[i] &lt;= m_lastSnapshotIncludeIndex) {</div><div class="ql-code-block">				<span class="ql-token hljs-comment">//改发送的日志已经被做成快照，必须发送快照了</span></div><div class="ql-code-block">                <span class="ql-token hljs-function">std::thread t(&amp;Raft::leaderSendSnapShot, this, i)</span>; </div><div class="ql-code-block">                t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">continue</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-comment">//发送心跳，构造发送值</span></div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> preLogIndex = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> PrevLogTerm = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">            <span class="ql-token hljs-built_in">getPrevLogInfo</span>(i, &amp;preLogIndex, &amp;PrevLogTerm);  <span class="ql-token hljs-comment">//获取本次发送的一系列日志的上一条日志的信息，以判断是否匹配</span></div><div class="ql-code-block">            std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; appendEntriesArgs = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::AppendEntriesArgs&gt;();</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_leaderid</span>(m_me);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_prevlogindex</span>(preLogIndex);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_prevlogterm</span>(PrevLogTerm);</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">clear_entries</span>();</div><div class="ql-code-block">            appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">set_leadercommit</span>(m_commitIndex);</div><div class="ql-code-block">            <span class="ql-token hljs-comment">// 作用是携带上prelogIndex的下一条日志及其之后的所有日志</span></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//leader对每个节点发送的日志长短不一，但是都保证从prevIndex发送直到最后</span></div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (preLogIndex != m_lastSnapshotIncludeIndex) {</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> j = <span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(preLogIndex) + <span class="ql-token hljs-number">1</span>; j &lt; m_logs.<span class="ql-token hljs-built_in">size</span>(); ++j) {</div><div class="ql-code-block">                    mprrpc::LogEntry *sendEntryPtr = appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">add_entries</span>();</div><div class="ql-code-block">                    *sendEntryPtr = m_logs[j];  </div><div class="ql-code-block">                }</div><div class="ql-code-block">            } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">const</span> <span class="ql-token hljs-keyword">auto</span>&amp; item: m_logs) {</div><div class="ql-code-block">                    mprrpc::LogEntry *sendEntryPtr = appendEntriesArgs-&gt;<span class="ql-token hljs-built_in">add_entries</span>();</div><div class="ql-code-block">                    *sendEntryPtr = item;  </div><div class="ql-code-block">                }</div><div class="ql-code-block">            }</div><div class="ql-code-block">            <span class="ql-token hljs-type">int</span> lastLogIndex = <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block">            <span class="ql-token hljs-comment">//初始化返回值</span></div><div class="ql-code-block">            <span class="ql-token hljs-type">const</span> std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; appendEntriesReply = std::<span class="ql-token hljs-built_in">make_shared</span>&lt;mprrpc::AppendEntriesReply&gt;();</div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-function">std::thread t(&amp;Raft::sendAppendEntries, this, i, appendEntriesArgs, appendEntriesReply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                          appendNums)</span>; <span class="ql-token hljs-comment">// 创建新线程并执行b函数，并传递参数</span></div><div class="ql-code-block">            t.<span class="ql-token hljs-built_in">detach</span>();</div><div class="ql-code-block">        }</div><div class="ql-code-block">        m_lastResetHearBeatTime = <span class="ql-token hljs-built_in">now</span>(); <span class="ql-token hljs-comment">//leader发送心跳，重置心跳时间，</span></div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div><div class="ql-code-block"><br></div></div><p><br></p><p>与选举不同的是<code>m_lastResetHearBeatTime</code> 是一个固定的时间，而选举超时时间是一定范围内的随机值。</p><p><br></p><p>这个的具体原因是为了避免很多节点一起发起选举而导致一直选不出<code>leader</code> 的情况。</p><p><br></p><p>为何选择随机时间而不选择其他的解决冲突的方法具体可见raft论文。</p><p><br></p><h4><strong>sendAppendEntries</strong></h4><p>无注释版：</p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">bool</span></div><div class="ql-code-block"><span class="ql-token hljs-function">Raft::sendAppendEntries(int server, std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; args, std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; reply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                        std::shared_ptr&lt;int&gt; appendNums) </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="ql-token hljs-built_in">AppendEntries</span>(args.<span class="ql-token hljs-built_in">get</span>(), reply.<span class="ql-token hljs-built_in">get</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!ok) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block">   </div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (reply-&gt;<span class="ql-token hljs-built_in">appstate</span>() == Disconnected) {  </div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; lg1(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(reply-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm){</div><div class="ql-code-block">        m_status = Follower;</div><div class="ql-code-block">        m_currentTerm = reply-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> <span class="ql-token hljs-keyword">if</span> (reply-&gt;<span class="ql-token hljs-built_in">term</span>() &lt; m_currentTerm) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_status != Leader) { </div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!reply-&gt;<span class="ql-token hljs-built_in">success</span>()){</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (reply-&gt;<span class="ql-token hljs-built_in">updatenextindex</span>()  != <span class="ql-token hljs-number">-100</span>) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">            m_nextIndex[server] = reply-&gt;<span class="ql-token hljs-built_in">updatenextindex</span>(); </div><div class="ql-code-block">        }</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">        *appendNums = *appendNums +<span class="ql-token hljs-number">1</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_matchIndex[server] = std::<span class="ql-token hljs-built_in">max</span>(m_matchIndex[server],args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>()+args-&gt;<span class="ql-token hljs-built_in">entries_size</span>()   );</div><div class="ql-code-block">        m_nextIndex[server] = m_matchIndex[server]+<span class="ql-token hljs-number">1</span>;</div><div class="ql-code-block">        <span class="ql-token hljs-type">int</span> lastLogIndex = <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (*appendNums &gt;= <span class="ql-token hljs-number">1</span>+m_peers.<span class="ql-token hljs-built_in">size</span>()/<span class="ql-token hljs-number">2</span>) { </div><div class="ql-code-block"><br></div><div class="ql-code-block">            *appendNums = <span class="ql-token hljs-number">0</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span>(args-&gt;<span class="ql-token hljs-built_in">entries_size</span>() &gt;<span class="ql-token hljs-number">0</span> &amp;&amp; args-&gt;<span class="ql-token hljs-built_in">entries</span>(args-&gt;<span class="ql-token hljs-built_in">entries_size</span>()<span class="ql-token hljs-number">-1</span>).<span class="ql-token hljs-built_in">logterm</span>() == m_currentTerm){</div><div class="ql-code-block">                m_commitIndex = std::<span class="ql-token hljs-built_in">max</span>(m_commitIndex,args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() + args-&gt;<span class="ql-token hljs-built_in">entries_size</span>());</div><div class="ql-code-block">            }</div><div class="ql-code-block">        }</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">}</div></div><p><br></p><p>带注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">bool</span></div><div class="ql-code-block"><span class="ql-token hljs-function">Raft::sendAppendEntries(int server, std::shared_ptr&lt;mprrpc::AppendEntriesArgs&gt; args, std::shared_ptr&lt;mprrpc::AppendEntriesReply&gt; reply,</span></div><div class="ql-code-block"><span class="ql-token hljs-function">                        std::shared_ptr&lt;int&gt; appendNums) </span>{</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// todo： paper中5.3节第一段末尾提到，如果append失败应该不断的retries ,直到这个log成功的被store</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-type">bool</span> ok = m_peers[server]-&gt;<span class="ql-token hljs-built_in">AppendEntries</span>(args.<span class="ql-token hljs-built_in">get</span>(), reply.<span class="ql-token hljs-built_in">get</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!ok) {</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-function">lock_guard&lt;mutex&gt; lg1(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//对reply进行处理</span></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// 对于rpc通信，无论什么时候都要检查term</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span>(reply-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm){</div><div class="ql-code-block">        m_status = Follower;</div><div class="ql-code-block">        m_currentTerm = reply-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>;</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> <span class="ql-token hljs-keyword">if</span> (reply-&gt;<span class="ql-token hljs-built_in">term</span>() &lt; m_currentTerm) {<span class="ql-token hljs-comment">//正常不会发生</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (m_status != Leader) { <span class="ql-token hljs-comment">//如果不是leader，那么就不要对返回的情况进行处理了</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-comment">//term相等</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (!reply-&gt;<span class="ql-token hljs-built_in">success</span>()){</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//日志不匹配，正常来说就是index要往前-1，既然能到这里，第一个日志（idnex = 1）发送后肯定是匹配的，因此不用考虑变成负数</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">//因为真正的环境不会知道是服务器宕机还是发生网络分区了</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (reply-&gt;<span class="ql-token hljs-built_in">updatenextindex</span>()  != <span class="ql-token hljs-number">-100</span>) {  <span class="ql-token hljs-comment">//-100只是一个特殊标记而已，没有太具体的含义</span></div><div class="ql-code-block">            <span class="ql-token hljs-comment">// 优化日志匹配，让follower决定到底应该下一次从哪一个开始尝试发送</span></div><div class="ql-code-block">            m_nextIndex[server] = reply-&gt;<span class="ql-token hljs-built_in">updatenextindex</span>();  </div><div class="ql-code-block">        }</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//	如果感觉rf.nextIndex数组是冗余的，看下论文fig2，其实不是冗余的</span></div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">        *appendNums = *appendNums +<span class="ql-token hljs-number">1</span>;   <span class="ql-token hljs-comment">//到这里代表同意接收了本次心跳或者日志</span></div><div class="ql-code-block">        </div><div class="ql-code-block">        m_matchIndex[server] = std::<span class="ql-token hljs-built_in">max</span>(m_matchIndex[server],args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>()+args-&gt;<span class="ql-token hljs-built_in">entries_size</span>()   );  <span class="ql-token hljs-comment">//同意了日志，就更新对应的m_matchIndex和m_nextIndex</span></div><div class="ql-code-block">        m_nextIndex[server] = m_matchIndex[server]+<span class="ql-token hljs-number">1</span>;</div><div class="ql-code-block">        <span class="ql-token hljs-type">int</span> lastLogIndex = <span class="ql-token hljs-built_in">getLastLogIndex</span>();</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (*appendNums &gt;= <span class="ql-token hljs-number">1</span> + m_peers.<span class="ql-token hljs-built_in">size</span>()/<span class="ql-token hljs-number">2</span>) { <span class="ql-token hljs-comment">//可以commit了</span></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//两种方法保证幂等性，1.赋值为0 	2.上面≥改为==</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">            *appendNums = <span class="ql-token hljs-number">0</span>;  <span class="ql-token hljs-comment">//置0</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//日志的安全性保证！！！！！ leader只有在当前term有日志提交的时候才更新commitIndex，因为raft无法保证之前term的Index是否提交</span></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//只有当前term有日志提交，之前term的log才可以被提交，只有这样才能保证“领导人完备性{当选领导人的节点拥有之前被提交的所有log，当然也可能有一些没有被提交的}”</span></div><div class="ql-code-block">            <span class="ql-token hljs-comment">//说白了就是只有当前term有日志提交才会提交</span></div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span>(args-&gt;<span class="ql-token hljs-built_in">entries_size</span>() &gt;<span class="ql-token hljs-number">0</span> &amp;&amp; args-&gt;<span class="ql-token hljs-built_in">entries</span>(args-&gt;<span class="ql-token hljs-built_in">entries_size</span>()<span class="ql-token hljs-number">-1</span>).<span class="ql-token hljs-built_in">logterm</span>() == m_currentTerm){</div><div class="ql-code-block">            </div><div class="ql-code-block">                m_commitIndex = std::<span class="ql-token hljs-built_in">max</span>(m_commitIndex,args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() + args-&gt;<span class="ql-token hljs-built_in">entries_size</span>());</div><div class="ql-code-block">            }</div><div class="ql-code-block"><br></div><div class="ql-code-block">        }</div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">return</span> ok;</div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p> m_nextIndex[server] = reply-&gt;updatenextindex(); 中涉及日志寻找匹配加速的优化</p><p><br></p><h4><strong>AppendEntries</strong>:</h4><p><br></p><p>无注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::AppendEntries1(const mprrpc:: AppendEntriesArgs *args,  mprrpc::AppendEntriesReply *reply) </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">std::lock_guard&lt;std::mutex&gt; locker(m_mtx)</span>;</div><div class="ql-code-block">    reply-&gt;<span class="ql-token hljs-built_in">set_appstate</span>(AppNormal);</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &lt; m_currentTerm) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(<span class="ql-token hljs-number">-100</span>); </div><div class="ql-code-block">         <span class="ql-token hljs-built_in">DPrintf</span>(<span class="ql-token hljs-string">"[func-AppendEntries-rf{%d}] 拒绝了 因为Leader{%d}的term{%v}&lt; rf{%d}.term{%d}\n"</span>, m_me, args-&gt;<span class="ql-token hljs-built_in">leaderid</span>(),args-&gt;<span class="ql-token hljs-built_in">term</span>() , m_me, m_currentTerm) ;</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>; </div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-function">Defer ec1([this]() -&gt; void { this-&gt;persist(); })</span>;</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_status = Follower;</div><div class="ql-code-block">        m_currentTerm = args-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>; </div><div class="ql-code-block">    }</div><div class="ql-code-block">    </div><div class="ql-code-block">    m_status = Follower; </div><div class="ql-code-block"><br></div><div class="ql-code-block">    m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();  </div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//	那么就比较日志，日志有3种情况</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() &gt; <span class="ql-token hljs-built_in">getLastLogIndex</span>()) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(<span class="ql-token hljs-built_in">getLastLogIndex</span>() + <span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">       </div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() &lt; m_lastSnapshotIncludeIndex) { </div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(m_lastSnapshotIncludeIndex + <span class="ql-token hljs-number">1</span>); </div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (<span class="ql-token hljs-built_in">matchLog</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>(), args-&gt;<span class="ql-token hljs-built_in">prevlogterm</span>())) {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt; args-&gt;<span class="ql-token hljs-built_in">entries_size</span>(); i++) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">auto</span> log = args-&gt;<span class="ql-token hljs-built_in">entries</span>(i);</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (log.<span class="ql-token hljs-built_in">logindex</span>() &gt; <span class="ql-token hljs-built_in">getLastLogIndex</span>()) { </div><div class="ql-code-block">                m_logs.<span class="ql-token hljs-built_in">push_back</span>(log);</div><div class="ql-code-block">            } <span class="ql-token hljs-keyword">else</span> { </div><div class="ql-code-block">                <span class="ql-token hljs-keyword">if</span> (m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())].<span class="ql-token hljs-built_in">logterm</span>() == log.<span class="ql-token hljs-built_in">logterm</span>() &amp;&amp;</div><div class="ql-code-block">                    m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())].<span class="ql-token hljs-built_in">command</span>() != log.<span class="ql-token hljs-built_in">command</span>()</div><div class="ql-code-block">                        ) { </div><div class="ql-code-block">                    <span class="ql-token hljs-built_in">myAssert</span>(<span class="ql-token hljs-literal">false</span>,</div><div class="ql-code-block">                             format(<span class="ql-token hljs-string">"[func-AppendEntries-rf{%d}] 两节点logIndex{%d}和term{%d}相同，但是其command{%d:%d}    {%d:%d}却不同！！\n"</span>,</div><div class="ql-code-block">                                    m_me, log.<span class="ql-token hljs-built_in">logindex</span>(), log.<span class="ql-token hljs-built_in">logterm</span>(), m_me,</div><div class="ql-code-block">                                    m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())].<span class="ql-token hljs-built_in">command</span>(), args-&gt;<span class="ql-token hljs-built_in">leaderid</span>(),</div><div class="ql-code-block">                                    log.<span class="ql-token hljs-built_in">command</span>()));</div><div class="ql-code-block">                }</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">if</span> (m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())].<span class="ql-token hljs-built_in">logterm</span>() != log.<span class="ql-token hljs-built_in">logterm</span>()) { <span class="ql-token hljs-comment">//不匹配就更新</span></div><div class="ql-code-block">                    m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())] = log;</div><div class="ql-code-block">                }</div><div class="ql-code-block">            }</div><div class="ql-code-block">        }</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-built_in">myAssert</span>(<span class="ql-token hljs-built_in">getLastLogIndex</span>() &gt;= args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() + args-&gt;<span class="ql-token hljs-built_in">entries_size</span>(),</div><div class="ql-code-block">                 format(<span class="ql-token hljs-string">"[func-AppendEntries1-rf{%d}]rf.getLastLogIndex(){%d} != args.PrevLogIndex{%d}+len(args.Entries){%d}"</span>,</div><div class="ql-code-block">                        m_me, <span class="ql-token hljs-built_in">getLastLogIndex</span>(), args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>(), args-&gt;<span class="ql-token hljs-built_in">entries_size</span>()));</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">leadercommit</span>() &gt; m_commitIndex) {</div><div class="ql-code-block">            m_commitIndex = std::<span class="ql-token hljs-built_in">min</span>(args-&gt;<span class="ql-token hljs-built_in">leadercommit</span>(), <span class="ql-token hljs-built_in">getLastLogIndex</span>());</div><div class="ql-code-block">        }</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-built_in">myAssert</span>(<span class="ql-token hljs-built_in">getLastLogIndex</span>() &gt;= m_commitIndex,</div><div class="ql-code-block">                 format(<span class="ql-token hljs-string">"[func-AppendEntries1-rf{%d}]  rf.getLastLogIndex{%d} &lt; rf.commitIndex{%d}"</span>, m_me,</div><div class="ql-code-block">                        <span class="ql-token hljs-built_in">getLastLogIndex</span>(), m_commitIndex));</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">true</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block"><br></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> index = args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>(); index &gt;= m_lastSnapshotIncludeIndex; --index) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (<span class="ql-token hljs-built_in">getLogTermFromLogIndex</span>(index) != <span class="ql-token hljs-built_in">getLogTermFromLogIndex</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>())) {</div><div class="ql-code-block">                reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(index + <span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">break</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">        }</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p>带注释版：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><span class="ql-token hljs-function">void Raft::AppendEntries1(const mprrpc:: AppendEntriesArgs *args,  mprrpc::AppendEntriesReply *reply) </span>{</div><div class="ql-code-block">    <span class="ql-token hljs-function">std::lock_guard&lt;std::mutex&gt; locker(m_mtx)</span>;</div><div class="ql-code-block"><br></div><div class="ql-code-block"><span class="ql-token hljs-comment">//	不同的人收到AppendEntries的反应是不同的，要注意无论什么时候收到rpc请求和响应都要检查term</span></div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &lt; m_currentTerm) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(<span class="ql-token hljs-number">-100</span>); <span class="ql-token hljs-comment">// 论文中：让领导人可以及时更新自己</span></div><div class="ql-code-block">         <span class="ql-token hljs-built_in">DPrintf</span>(<span class="ql-token hljs-string">"[func-AppendEntries-rf{%d}] 拒绝了 因为Leader{%d}的term{%v}&lt; rf{%d}.term{%d}\n"</span>, m_me, args-&gt;<span class="ql-token hljs-built_in">leaderid</span>(),args-&gt;<span class="ql-token hljs-built_in">term</span>() , m_me, m_currentTerm) ;</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>; <span class="ql-token hljs-comment">// 注意从过期的领导人收到消息不要重设定时器</span></div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-function">Defer ec1([this]() -&gt; void { this-&gt;persist(); })</span>;<span class="ql-token hljs-comment">//由于这个局部变量创建在锁之后，因此执行persist的时候应该也是拿到锁的.    //本质上就是使用raii的思想让persist()函数执行完之后再执行</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">term</span>() &gt; m_currentTerm) {</div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 三变 ,防止遗漏，无论什么时候都是三变</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">        m_status = Follower;</div><div class="ql-code-block">        m_currentTerm = args-&gt;<span class="ql-token hljs-built_in">term</span>();</div><div class="ql-code-block">        m_votedFor = <span class="ql-token hljs-number">-1</span>; <span class="ql-token hljs-comment">// 这里设置成-1有意义，如果突然宕机然后上线理论上是可以投票的</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 这里可不返回，应该改成让改节点尝试接收日志</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 如果是领导人和candidate突然转到Follower好像也不用其他操作</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 如果本来就是Follower，那么其term变化，相当于“不言自明”的换了追随的对象，因为原来的leader的term更小，是不会再接收其消息了</span></div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// 如果发生网络分区，那么candidate可能会收到同一个term的leader的消息，要转变为Follower，为了和上面，因此直接写</span></div><div class="ql-code-block">    m_status = Follower; <span class="ql-token hljs-comment">// 这里是有必要的，因为如果candidate收到同一个term的leader的AE，需要变成follower</span></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// term相等</span></div><div class="ql-code-block">    m_lastResetElectionTime = <span class="ql-token hljs-built_in">now</span>();    <span class="ql-token hljs-comment">//重置选举超时定时器</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// 不能无脑的从prevlogIndex开始阶段日志，因为rpc可能会延迟，导致发过来的log是很久之前的</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">    <span class="ql-token hljs-comment">//	那么就比较日志，日志有3种情况</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() &gt; <span class="ql-token hljs-built_in">getLastLogIndex</span>()) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(<span class="ql-token hljs-built_in">getLastLogIndex</span>() + <span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>() &lt; m_lastSnapshotIncludeIndex) { <span class="ql-token hljs-comment">// 如果prevlogIndex还没有更上快照</span></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(m_lastSnapshotIncludeIndex + <span class="ql-token hljs-number">1</span>); </div><div class="ql-code-block">    }</div><div class="ql-code-block">    <span class="ql-token hljs-comment">//	本机日志有那么长，冲突(same index,different term),截断日志</span></div><div class="ql-code-block">    <span class="ql-token hljs-comment">// 注意：这里目前当args.PrevLogIndex == rf.lastSnapshotIncludeIndex与不等的时候要分开考虑，可以看看能不能优化这块</span></div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (<span class="ql-token hljs-built_in">matchLog</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>(), args-&gt;<span class="ql-token hljs-built_in">prevlogterm</span>())) {</div><div class="ql-code-block">        <span class="ql-token hljs-comment">//日志匹配，那么就复制日志</span></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> i = <span class="ql-token hljs-number">0</span>; i &lt; args-&gt;<span class="ql-token hljs-built_in">entries_size</span>(); i++) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">auto</span> log = args-&gt;<span class="ql-token hljs-built_in">entries</span>(i);</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (log.<span class="ql-token hljs-built_in">logindex</span>() &gt; <span class="ql-token hljs-built_in">getLastLogIndex</span>()) { <span class="ql-token hljs-comment">//超过就直接添加日志</span></div><div class="ql-code-block">                m_logs.<span class="ql-token hljs-built_in">push_back</span>(log);</div><div class="ql-code-block">            } <span class="ql-token hljs-keyword">else</span> {  <span class="ql-token hljs-comment">//没超过就比较是否匹配，不匹配再更新，而不是直接截断</span></div><div class="ql-code-block"><br></div><div class="ql-code-block">                <span class="ql-token hljs-keyword">if</span> (m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())].<span class="ql-token hljs-built_in">logterm</span>() != log.<span class="ql-token hljs-built_in">logterm</span>()) { <span class="ql-token hljs-comment">//不匹配就更新</span></div><div class="ql-code-block">                    m_logs[<span class="ql-token hljs-built_in">getSlicesIndexFromLogIndex</span>(log.<span class="ql-token hljs-built_in">logindex</span>())] = log;</div><div class="ql-code-block">                }</div><div class="ql-code-block">            }</div><div class="ql-code-block">        }</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">if</span> (args-&gt;<span class="ql-token hljs-built_in">leadercommit</span>() &gt; m_commitIndex) {</div><div class="ql-code-block">            m_commitIndex = std::<span class="ql-token hljs-built_in">min</span>(args-&gt;<span class="ql-token hljs-built_in">leadercommit</span>(), <span class="ql-token hljs-built_in">getLastLogIndex</span>());<span class="ql-token hljs-comment">// 这个地方不能无脑跟上getLastLogIndex()，因为可能存在args-&gt;leadercommit()落后于 getLastLogIndex()的情况</span></div><div class="ql-code-block">        }</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 领导会一次发送完所有的日志</span></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">true</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block"><br></div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    } <span class="ql-token hljs-keyword">else</span> {</div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 不匹配，不匹配不是一个一个往前，而是有优化加速</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// PrevLogIndex 长度合适，但是不匹配，因此往前寻找 矛盾的term的第一个元素</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// 为什么该term的日志都是矛盾的呢？也不一定都是矛盾的，只是这么优化减少rpc而已</span></div><div class="ql-code-block">        <span class="ql-token hljs-comment">// ？什么时候term会矛盾呢？很多情况，比如leader接收了日志之后马上就崩溃等等</span></div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> index = args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>(); index &gt;= m_lastSnapshotIncludeIndex; --index) {</div><div class="ql-code-block">            <span class="ql-token hljs-keyword">if</span> (<span class="ql-token hljs-built_in">getLogTermFromLogIndex</span>(index) != <span class="ql-token hljs-built_in">getLogTermFromLogIndex</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>())) {</div><div class="ql-code-block">                reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(index + <span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">                <span class="ql-token hljs-keyword">break</span>;</div><div class="ql-code-block">            }</div><div class="ql-code-block">        }</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block"><br></div><div class="ql-code-block">        <span class="ql-token hljs-keyword">return</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block"><br></div><div class="ql-code-block">}</div></div><p><br></p><p><br></p><p><br></p><p><br></p><h3>日志寻找匹配加速</h3><p><br></p><p>这部分在<code>AppendEntries</code>  函数部分。</p><p><br></p><p>涉及代码：</p><p><br></p><div class="ql-code-block-container"><div class="ql-code-block"><br></div><div class="ql-code-block"><span class="ql-token hljs-comment">// 不匹配，不匹配不是一个一个往前，而是有优化加速</span></div><div class="ql-code-block"><span class="ql-token hljs-comment">// PrevLogIndex 长度合适，但是不匹配，因此往前寻找 矛盾的term的第一个元素</span></div><div class="ql-code-block"><span class="ql-token hljs-comment">// 为什么该term的日志都是矛盾的呢？也不一定都是矛盾的，只是这么优化减少rpc而已</span></div><div class="ql-code-block"><span class="ql-token hljs-comment">// ？什么时候term会矛盾呢？很多情况，比如leader接收了日志之后马上就崩溃等等</span></div><div class="ql-code-block">reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>());</div><div class="ql-code-block"><br></div><div class="ql-code-block"><span class="ql-token hljs-keyword">for</span> (<span class="ql-token hljs-type">int</span> index = args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>(); index &gt;= m_lastSnapshotIncludeIndex; --index) {</div><div class="ql-code-block">    <span class="ql-token hljs-keyword">if</span> (<span class="ql-token hljs-built_in">getLogTermFromLogIndex</span>(index) != <span class="ql-token hljs-built_in">getLogTermFromLogIndex</span>(args-&gt;<span class="ql-token hljs-built_in">prevlogindex</span>())) {</div><div class="ql-code-block">        reply-&gt;<span class="ql-token hljs-built_in">set_updatenextindex</span>(index + <span class="ql-token hljs-number">1</span>);</div><div class="ql-code-block">        <span class="ql-token hljs-keyword">break</span>;</div><div class="ql-code-block">    }</div><div class="ql-code-block">}</div><div class="ql-code-block"><br></div><div class="ql-code-block">reply-&gt;<span class="ql-token hljs-built_in">set_success</span>(<span class="ql-token hljs-literal">false</span>);</div><div class="ql-code-block">reply-&gt;<span class="ql-token hljs-built_in">set_term</span>(m_currentTerm);</div><div class="ql-code-block"><br></div><div class="ql-code-block"><span class="ql-token hljs-keyword">return</span>;</div></div><p><br></p><p><br></p><p>前篇也说过，如果日志不匹配的话可以一个一个往前的倒退。但是这样的话可能会设计很多个rpc之后才能找到匹配的日志，那么就一次多倒退几个数。</p><p><br></p><p>倒退几个呢？这里认为如果某一个日志不匹配，那么这一个日志所在的term的所有日志大概率都不匹配，那么就倒退到 最后一个日志所在的term的最后那个命令。</p><p><br></p><h3>其他</h3><p><br></p><h4>snapshot快照</h4><p><br></p><h5>快照是什么？</h5><p><br></p><p>当在Raft协议中的日志变得太大时，为了避免无限制地增长，系统可能会采取快照（snapshot）的方式来压缩日志。快照是系统状态的一种紧凑表示形式，包含在某个特定时间点的所有必要信息，以便在需要时能够还原整个系统状态。</p><p><br></p><p>如果你学习过redis，那么快照说白了就是rdb，而raft的日志可以看成是aof日志。rdb的目的只是为了崩溃恢复的加速，如果没有的话也不会影响系统的正确性，这也是为什么选择不详细讲解快照的原因，因为只是日志的压缩而已。</p><p><br></p><h5>何时创建快照？</h5><p><br></p><p> 快照通常在日志达到一定大小时创建。这有助于限制日志的大小，防止无限制的增长。快照也可以在系统空闲时（没有新的日志条目被追加）创建。</p><p><br></p><h5>快照的传输</h5><p><br></p><p>快照的传输主要涉及：kv数据库与raft节点之间；不同raft节点之间。</p><p><br></p><p>kv数据库与raft节点之间：因为快照是数据库的压缩表示，因此需要由数据库打包快照，并交给raft节点。当快照生成之后，快照内设计的操作会被raft节点从日志中删除（不删除就相当于有两份数据，冗余了）。</p><p><br></p><p>不同raft节点之间：当leader已经把某个日志及其之前的内容变成了快照，那么当涉及这部的同步时，就只能通过快照来发送。</p><p><br></p><h4>内容补充</h4><p><br></p><h5>对 m_nextIndex 和 m_matchIndex作用的补充：</h5><p><br></p><p><code>m_nextIndex</code> 保存leader下一次应该从哪一个日志开始发送给follower；m_matchIndex表示follower在哪一个日志是已经匹配了的（由于日志安全性，某一个日志匹配，那么这个日志及其之前的日志都是匹配的）</p><p><br></p><p>一个比较容易弄错的问题是：<code>m_nextIndex</code> 与<code>m_matchIndex</code> 是否有冗余，即使用一个<code>m_nextIndex</code> 可以吗？</p><p><br></p><p>显然是不行的，<code>m_nextIndex</code> 的作用是用来寻找<code>m_matchIndex</code> ，不能直接取代。我们可以从这两个变量的变化看，在当选leader后，<code>m_nextIndex</code> 初始化为最新日志index，<code>m_matchIndex</code> 初始化为0，如果日志不匹配，那么<code>m_nextIndex</code> 就会不断的缩减，直到遇到匹配的日志，这时候<code>m_nextIndex</code> 应该一直为<code>m_matchIndex+1</code> 。</p><p><br></p><p>如果一直不发生故障，那么后期m_nextIndex就没有太大作用了，但是raft考虑需要考虑故障的情况，因此需要使用两个变量。</p><p><br></p><h4>你可以尝试思考的问题</h4><p><br></p><ol><li data-list="bullet"><span class="ql-ui"></span>锁，能否在其中的某个地方提前放锁，或者使用多把锁来尝试提升性能？</li><li data-list="bullet"><span class="ql-ui"></span>多线程发送，能不能直接在doHeartBeat或者doElection函数里面直接一个一个发送消息呢？</li></ol><p><br></p><h4>可以有的优化空间：</h4><p><br></p><ol><li data-list="bullet"><span class="ql-ui"></span>线程池，而不是每次rpc都不断地创建新线程</li><li data-list="bullet"><span class="ql-ui"></span>日志</li><li data-list="bullet"><span class="ql-ui"></span>从节点读取日志</li></ol><p><br></p><h4>后期内容预告！</h4><p><br></p><ol><li data-list="bullet"><span class="ql-ui"></span>剩余辅助函数的逻辑。</li><li data-list="bullet"><span class="ql-ui"></span>持久化：raft哪些变量需要持久化</li><li data-list="bullet"><span class="ql-ui"></span>rpc：如何实现一个简单的rpc通信</li></ol><p><br></p><p>哦吼！差点忘记了，大家都喜欢show me the code（文本阅读源码太无聊），俺们的代码仓库在<a href="https://github.com/youngyangyang04/KVstorageBaseRaft-cpp" target="_blank">这里</a>，目前已经可以尝试一个rpc的简单运行了，运行方式在首页的README中。</p><p><br></p><p>走过路过不要忘记点一个star。</p><p><br></p><p>非常欢迎大家：对代码提出issue问题；尝试优化优化；添加新功能；捉虫。</p><p><br></p><p>下一章开始我们应该就可以尝试运行起来raft了，敬请期待。</p><p><br></p><p>由于近期比较忙，更新稍晚，抱歉。</p></div>
        </div>
        <footer>
                <div class="horizon-line"></div>
                <img id="logo" src="./CPPRaft系列-raft算法主要流程函数实现-03_files/logo@1x.png">
                <div class="text">知识星球</div>
                <div class="horizon-line"></div>
        </footer>
        <div class="qrcode-container">
            <img class="qrcode" id="qrcode" src="data:image/png;base64,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">
            <div class="text-desc">扫码加入星球</div>
            <div class="text-desc">查看更多优质内容</div>
        </div>
        <div id="qrcode-url">https://wx.zsxq.com/mweb/views/joingroup/join_group.html?group_id=88511825151142</div>
        <input type="hidden" name="group_allow_copy" value="true">
        <input type="hidden" name="group_enable_watermark" value="true">
        <input type="hidden" name="member_id" value="581154221814144">
        <input type="hidden" name="member_name" value="西瓜">
        <input type="hidden" name="member_role" value="other">
    </div>
    <div class="message-container-overlay">
    </div>
    <script src="./CPPRaft系列-raft算法主要流程函数实现-03_files/jr-qrcode.js.下载"></script>
    <script src="./CPPRaft系列-raft算法主要流程函数实现-03_files/content-protection.js.下载"></script>
    <script src="./CPPRaft系列-raft算法主要流程函数实现-03_files/article_dweb.js.下载"></script><style>.content img.fr-dib {margin:5px auto;display:block;float:none}.content img.fr-dib.fr-fil {margin-left:0;text-align:left}.content img.fr-dib.fr-fir {margin-right:0;text-algin:right}</style>


</body></html>